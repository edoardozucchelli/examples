{"traceEvents": [{"ph": "M", "pid": 7726, "tid": 7726, "name": "process_name", "args": {"name": "MainProcess"}}, {"ph": "M", "pid": 7726, "tid": 7729, "name": "thread_name", "args": {"name": "ThreadPoolExecutor-0_2"}}, {"ph": "M", "pid": 7726, "tid": 7728, "name": "thread_name", "args": {"name": "ThreadPoolExecutor-0_1"}}, {"ph": "M", "pid": 7726, "tid": 7727, "name": "thread_name", "args": {"name": "ThreadPoolExecutor-0_0"}}, {"ph": "M", "pid": 7726, "tid": 7726, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 7726, "tid": 7726, "ts": 10439077886.559, "dur": 0.684, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077890.906, "dur": 0.553, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077890.128, "dur": 1.482, "name": "_acquireLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:214)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077892.047, "dur": 0.174, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077893.915, "dur": 0.153, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077894.392, "dur": 0.09, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077894.884, "dur": 0.047, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077895.137, "dur": 0.043, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077895.307, "dur": 0.04, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077898.177, "dur": 0.747, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:772)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077899.983, "dur": 0.131, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077899.561, "dur": 0.688, "name": "_checkLevel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077901.992, "dur": 0.188, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077901.727, "dur": 0.531, "name": "_acquireLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:214)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077903.53, "dur": 0.09, "name": "list.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077904.338, "dur": 0.116, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077903.935, "dur": 0.599, "name": "_releaseLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:223)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077901.432, "dur": 3.235, "name": "_addHandlerRef (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:839)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077905.926, "dur": 0.57, "name": "RLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077907.621, "dur": 0.099, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077907.418, "dur": 0.355, "name": "_acquireLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:214)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077910.737, "dur": 0.261, "name": "set.add", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077908.944, "dur": 2.24, "name": "add (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077911.54, "dur": 0.061, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077911.421, "dur": 0.228, "name": "_releaseLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:223)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077907.246, "dur": 4.578, "name": "_register_at_fork_reinit_lock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:244)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077905.173, "dur": 6.745, "name": "createLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:887)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077897.494, "dur": 14.513, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:858)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077896.6, "dur": 16.507, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1047)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077913.558, "dur": 0.134, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077913.808, "dur": 0.12, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077914.677, "dur": 0.083, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077917.003, "dur": 0.612, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:420)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077919.215, "dur": 4.854, "name": "re.Pattern.search", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077918.63, "dur": 5.723, "name": "validate (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:426)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077915.919, "dur": 8.928, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:555)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077925.983, "dur": 0.229, "name": "setFormatter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:955)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077927.59, "dur": 0.185, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077927.397, "dur": 0.444, "name": "_acquireLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:214)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077928.22, "dur": 0.107, "name": "list.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077928.676, "dur": 0.064, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077928.533, "dur": 0.257, "name": "_releaseLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:223)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077927.104, "dur": 1.765, "name": "addHandler (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1589)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077929.078, "dur": 0.101, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077930.336, "dur": 0.053, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077930.169, "dur": 0.338, "name": "_checkLevel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077932.574, "dur": 0.092, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077932.427, "dur": 2.199, "name": "_acquireLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:214)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077935.015, "dur": 0.127, "name": "dict.values", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077935.684, "dur": 0.041, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077936.251, "dur": 0.096, "name": "dict.clear", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077936.513, "dur": 0.424, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077937.272, "dur": 0.048, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077937.784, "dur": 0.038, "name": "dict.clear", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077938.242, "dur": 0.037, "name": "dict.clear", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077938.575, "dur": 0.05, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077938.461, "dur": 0.225, "name": "_releaseLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:223)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077932.169, "dur": 6.658, "name": "_clear_cache (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077929.798, "dur": 9.156, "name": "setLevel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1405)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077939.401, "dur": 0.15, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077939.295, "dur": 0.314, "name": "_releaseLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:223)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077889.427, "dur": 50.276, "name": "basicConfig (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1893)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077940.953, "dur": 0.251, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077940.508, "dur": 0.916, "name": "__init__ (/home/edx/PycharmProjects/examples/threads/race_conditions.py:13)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077942.702, "dur": 0.151, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077947.189, "dur": 0.25, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077947.034, "dur": 0.474, "name": "_acquireLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:214)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077948.279, "dur": 0.302, "name": "getEffectiveLevel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1663)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077949.14, "dur": 0.08, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077949.026, "dur": 0.245, "name": "_releaseLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:223)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077945.024, "dur": 4.569, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077952.205, "dur": 0.216, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077951.765, "dur": 0.731, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077953.44, "dur": 0.199, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077955.054, "dur": 0.132, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077954.691, "dur": 0.546, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077955.623, "dur": 0.085, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077956.244, "dur": 0.036, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077956.143, "dur": 0.188, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077951.373, "dur": 5.717, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077959.729, "dur": 0.368, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077960.775, "dur": 0.103, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077968.212, "dur": 0.346, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077971.983, "dur": 0.101, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077976.616, "dur": 0.097, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077975.792, "dur": 63.315, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077975.597, "dur": 63.679, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078041.28, "dur": 0.166, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078040.004, "dur": 2.491, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078039.888, "dur": 2.669, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078043.437, "dur": 0.105, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078042.883, "dur": 1.173, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078042.786, "dur": 1.318, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078045.112, "dur": 0.097, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078044.395, "dur": 3.124, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078044.317, "dur": 3.256, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078048.587, "dur": 0.103, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078047.923, "dur": 1.359, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078047.85, "dur": 1.513, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078050.514, "dur": 0.095, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078052.52, "dur": 0.1, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078054.245, "dur": 0.084, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078053.572, "dur": 1.421, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078053.484, "dur": 1.557, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078051.588, "dur": 3.713, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078051.443, "dur": 3.908, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078049.638, "dur": 5.982, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078049.566, "dur": 6.105, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078056.556, "dur": 0.096, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078056.021, "dur": 1.157, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078055.949, "dur": 1.278, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078058.32, "dur": 0.097, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078057.514, "dur": 1.395, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078057.447, "dur": 1.511, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077971.145, "dur": 88.121, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077971.011, "dur": 88.311, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078060.517, "dur": 0.097, "name": "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078059.637, "dur": 1.625, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078059.579, "dur": 1.734, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077966.364, "dur": 95.197, "name": "_abc._abc_subclasscheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077966.241, "dur": 95.376, "name": "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077963.31, "dur": 98.514, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077963.045, "dur": 98.846, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077962.222, "dur": 99.909, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078063.204, "dur": 0.488, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078062.874, "dur": 1.032, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078065.992, "dur": 0.086, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078066.405, "dur": 0.21, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078066.255, "dur": 0.456, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078066.932, "dur": 0.519, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078065.757, "dur": 2.386, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078069.264, "dur": 0.07, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078069.476, "dur": 0.084, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078070.581, "dur": 0.202, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078070.957, "dur": 0.131, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078070.267, "dur": 1.794, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078069.129, "dur": 3.063, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078076.713, "dur": 0.215, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078077.666, "dur": 0.066, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078077.473, "dur": 0.572, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078080.116, "dur": 0.342, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078081.238, "dur": 0.345, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078083.268, "dur": 0.511, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078085.427, "dur": 0.432, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078086.243, "dur": 0.202, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078086.598, "dur": 0.961, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077959.287, "dur": 128.555, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077958.237, "dur": 130.273, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078089.818, "dur": 0.651, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078092.62, "dur": 0.181, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078093.482, "dur": 0.285, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078093.192, "dur": 0.677, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078095.859, "dur": 3.933, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078104.542, "dur": 0.443, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078104.136, "dur": 1.005, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078100.641, "dur": 4.615, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078106.782, "dur": 4.399, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078111.783, "dur": 4.658, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078106.35, "dur": 10.244, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078120.27, "dur": 3.888, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078119.791, "dur": 4.505, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078119.363, "dur": 5.036, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078095.347, "dur": 29.408, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078094.734, "dur": 30.161, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078126.507, "dur": 7.11, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078134.692, "dur": 0.294, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078134.41, "dur": 0.66, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078135.581, "dur": 0.306, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078136.066, "dur": 0.593, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078137.224, "dur": 0.093, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078137.056, "dur": 0.317, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078134.134, "dur": 3.369, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078094.246, "dur": 43.38, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078138.031, "dur": 0.064, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078137.917, "dur": 0.227, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078092.207, "dur": 46.037, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078091.021, "dur": 48.262, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078089.215, "dur": 50.232, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077950.508, "dur": 189.069, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077944.353, "dur": 196.279, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077942.366, "dur": 198.577, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078145.25, "dur": 0.238, "name": "parent (<frozen importlib._bootstrap>:389)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078148.096, "dur": 0.451, "name": "__init__ (<frozen importlib._bootstrap>:143)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078149.327, "dur": 0.215, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078151.338, "dur": 0.282, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078151.91, "dur": 0.096, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078151.164, "dur": 1.39, "name": "__init__ (<frozen importlib._bootstrap>:58)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078155.764, "dur": 0.215, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078149.1, "dur": 7.003, "name": "_get_module_lock (<frozen importlib._bootstrap>:157)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078156.774, "dur": 0.125, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078156.568, "dur": 2.436, "name": "acquire (<frozen importlib._bootstrap>:78)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078148.898, "dur": 10.21, "name": "__enter__ (<frozen importlib._bootstrap>:147)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078159.554, "dur": 0.151, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078160.221, "dur": 0.419, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078163.275, "dur": 0.143, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078163.128, "dur": 0.384, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078163.929, "dur": 0.143, "name": "find_spec (<frozen importlib._bootstrap>:725)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078164.481, "dur": 0.106, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078164.388, "dur": 0.245, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078165.341, "dur": 0.08, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078165.23, "dur": 0.241, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078165.918, "dur": 0.336, "name": "_imp.is_frozen", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078165.778, "dur": 0.563, "name": "find_spec (<frozen importlib._bootstrap>:800)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078166.566, "dur": 0.059, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078166.478, "dur": 0.191, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078167.071, "dur": 0.059, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078166.985, "dur": 0.188, "name": "__enter__ (<frozen importlib._bootstrap>:863)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078168.954, "dur": 0.195, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078169.521, "dur": 0.492, "name": "_path_importer_cache (<frozen importlib._bootstrap_external>:1265)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078170.252, "dur": 0.278, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078170.978, "dur": 0.142, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078171.778, "dur": 6.96, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078171.515, "dur": 7.357, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078180.089, "dur": 0.081, "name": "_relax_case (<frozen importlib._bootstrap_external>:40)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078182.364, "dur": 0.209, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078182.89, "dur": 0.07, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078181.986, "dur": 1.115, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078183.412, "dur": 0.359, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078181.412, "dur": 2.556, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078184.556, "dur": 0.443, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078186.085, "dur": 0.076, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078186.304, "dur": 0.06, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078185.936, "dur": 0.499, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078186.577, "dur": 0.12, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078185.671, "dur": 1.099, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078187.099, "dur": 0.182, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078188.04, "dur": 0.065, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078188.224, "dur": 0.051, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078187.93, "dur": 0.414, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078188.462, "dur": 0.111, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078187.766, "dur": 0.907, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078188.912, "dur": 0.138, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078189.976, "dur": 0.07, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078191.849, "dur": 0.067, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078189.867, "dur": 2.139, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078192.132, "dur": 0.117, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078189.71, "dur": 2.598, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078192.656, "dur": 0.142, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078193.912, "dur": 3.528, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078193.746, "dur": 3.783, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078193.556, "dur": 4.541, "name": "_path_is_mode_type (<frozen importlib._bootstrap_external>:90)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078193.295, "dur": 5.181, "name": "_path_isfile (<frozen importlib._bootstrap_external>:99)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078199.443, "dur": 0.717, "name": "__init__ (<frozen importlib._bootstrap_external>:939)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078200.959, "dur": 0.146, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078202.12, "dur": 0.57, "name": "__init__ (<frozen importlib._bootstrap>:342)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078200.669, "dur": 2.938, "name": "spec_from_file_location (<frozen importlib._bootstrap_external>:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078198.985, "dur": 4.804, "name": "_get_spec (<frozen importlib._bootstrap_external>:1426)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078170.813, "dur": 33.252, "name": "find_spec (<frozen importlib._bootstrap_external>:1431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078168.175, "dur": 36.33, "name": "_get_spec (<frozen importlib._bootstrap_external>:1302)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078167.616, "dur": 37.343, "name": "find_spec (<frozen importlib._bootstrap_external>:1334)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078205.501, "dur": 0.121, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078205.323, "dur": 0.361, "name": "__exit__ (<frozen importlib._bootstrap>:867)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078162.056, "dur": 44.214, "name": "_find_spec (<frozen importlib._bootstrap>:890)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078206.944, "dur": 0.229, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078207.495, "dur": 0.115, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078207.836, "dur": 0.071, "name": "create_module (<frozen importlib._bootstrap_external>:774)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078208.189, "dur": 0.879, "name": "_new_module (<frozen importlib._bootstrap>:35)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078209.596, "dur": 0.151, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078209.949, "dur": 0.083, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078210.471, "dur": 0.062, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078211.011, "dur": 0.277, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078210.752, "dur": 0.702, "name": "parent (<frozen importlib._bootstrap>:389)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078211.812, "dur": 2.167, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078214.22, "dur": 0.142, "name": "has_location (<frozen importlib._bootstrap>:397)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078214.51, "dur": 0.95, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078216.039, "dur": 0.906, "name": "builtins.getattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078218.167, "dur": 0.488, "name": "str.endswith", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078219.262, "dur": 0.049, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078219.692, "dur": 0.207, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078220.134, "dur": 0.169, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078219.46, "dur": 1.086, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078220.773, "dur": 0.163, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078221.651, "dur": 0.215, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078224.086, "dur": 0.101, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078224.337, "dur": 0.069, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078224.572, "dur": 0.048, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078223.934, "dur": 0.791, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078224.927, "dur": 0.256, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078223.659, "dur": 1.634, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078218.975, "dur": 6.438, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078217.614, "dur": 9.805, "name": "_get_cached (<frozen importlib._bootstrap_external>:424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078217.093, "dur": 10.642, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078228.045, "dur": 0.145, "name": "cached (<frozen importlib._bootstrap>:376)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078209.344, "dur": 19.052, "name": "_init_module_attrs (<frozen importlib._bootstrap>:477)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078207.343, "dur": 21.246, "name": "module_from_spec (<frozen importlib._bootstrap>:549)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078231.012, "dur": 0.111, "name": "get_filename (<frozen importlib._bootstrap_external>:964)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078230.151, "dur": 1.103, "name": "_check_name_wrapper (<frozen importlib._bootstrap_external>:456)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078231.837, "dur": 0.049, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078232.109, "dur": 0.118, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078232.382, "dur": 0.176, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078231.989, "dur": 0.722, "name": "_path_split (<frozen importlib._bootstrap_external>:68)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078232.842, "dur": 0.121, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078233.359, "dur": 0.136, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078234.849, "dur": 0.074, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078235.056, "dur": 0.049, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078235.234, "dur": 0.048, "name": "str.rstrip", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078234.713, "dur": 0.661, "name": "<listcomp> (<frozen importlib._bootstrap_external>:64)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078235.515, "dur": 0.135, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078234.489, "dur": 1.235, "name": "_path_join (<frozen importlib._bootstrap_external>:62)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078231.648, "dur": 4.178, "name": "cache_from_source (<frozen importlib._bootstrap_external>:294)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078236.584, "dur": 3.635, "name": "posix.stat", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078236.446, "dur": 3.879, "name": "_path_stat (<frozen importlib._bootstrap_external>:80)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078236.319, "dur": 4.592, "name": "path_stats (<frozen importlib._bootstrap_external>:1010)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078242.28, "dur": 0.241, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078243.078, "dur": 15.506, "name": "io.open_code", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078259.527, "dur": 6.681, "name": "_io.BufferedReader.read", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078241.959, "dur": 27.711, "name": "get_data (<frozen importlib._bootstrap_external>:969)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078272.134, "dur": 0.168, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078272.951, "dur": 0.056, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078273.438, "dur": 0.265, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078272.822, "dur": 0.984, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078271.119, "dur": 3.128, "name": "_classify_pyc (<frozen importlib._bootstrap_external>:493)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078276.472, "dur": 0.069, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078276.679, "dur": 0.133, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078276.406, "dur": 0.466, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078277.444, "dur": 0.038, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078277.59, "dur": 0.116, "name": "type.from_bytes", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078277.382, "dur": 0.38, "name": "_unpack_uint32 (<frozen importlib._bootstrap_external>:51)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078276.159, "dur": 1.795, "name": "_validate_timestamp_pyc (<frozen importlib._bootstrap_external>:526)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078278.543, "dur": 0.391, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078279.625, "dur": 45.038, "name": "marshal.loads", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078325.049, "dur": 0.177, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078325.636, "dur": 0.29, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078326.355, "dur": 0.761, "name": "_imp._fix_co_filename", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078279.402, "dur": 47.799, "name": "_compile_bytecode (<frozen importlib._bootstrap_external>:578)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078229.72, "dur": 97.66, "name": "get_code (<frozen importlib._bootstrap_external>:849)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078333.261, "dur": 0.094, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078333.633, "dur": 0.405, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078332.921, "dur": 1.291, "name": "_handle_fromlist (<frozen importlib._bootstrap>:1017)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078338.495, "dur": 3.815, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:343)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078343.012, "dur": 0.557, "name": "atexit.register", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078344.68, "dur": 0.608, "name": "_WorkItem (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:45)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078343.988, "dur": 29.754, "name": "builtins.__build_class__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078379.282, "dur": 0.544, "name": "BrokenThreadPool (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:109)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078375.397, "dur": 22.88, "name": "builtins.__build_class__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078399.997, "dur": 4.954, "name": "ThreadPoolExecutor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:115)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078399.603, "dur": 17.055, "name": "builtins.__build_class__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078331.176, "dur": 85.653, "name": "<module> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:4)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078330.429, "dur": 86.676, "name": "builtins.exec", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078330.17, "dur": 87.022, "name": "_call_with_frames_removed (<frozen importlib._bootstrap>:211)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078229.486, "dur": 188.009, "name": "exec_module (<frozen importlib._bootstrap_external>:777)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078419.436, "dur": 0.264, "name": "dict.pop", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078420.673, "dur": 0.455, "name": "_verbose_message (<frozen importlib._bootstrap>:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078206.691, "dur": 214.924, "name": "_load_unlocked (<frozen importlib._bootstrap>:650)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078422.387, "dur": 0.546, "name": "str.rpartition", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078423.318, "dur": 0.69, "name": "builtins.setattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078159.971, "dur": 264.181, "name": "_find_and_load_unlocked (<frozen importlib._bootstrap>:956)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078425.346, "dur": 0.243, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078425.148, "dur": 2.875, "name": "release (<frozen importlib._bootstrap>:103)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078424.78, "dur": 3.397, "name": "__exit__ (<frozen importlib._bootstrap>:151)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078429.086, "dur": 0.152, "name": "_imp.acquire_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078429.476, "dur": 0.142, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078430.105, "dur": 0.106, "name": "_imp.release_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078428.903, "dur": 1.375, "name": "cb (<frozen importlib._bootstrap>:176)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078147.542, "dur": 283.514, "name": "_find_and_load (<frozen importlib._bootstrap>:986)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078144.266, "dur": 289.486, "name": "__getattr__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/__init__.py:40)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078438.203, "dur": 0.164, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078438.884, "dur": 6.016, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078437.813, "dur": 7.73, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:388)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078447.321, "dur": 0.157, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078435.111, "dur": 15.055, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:120)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078451.333, "dur": 0.066, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:632)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078453.642, "dur": 0.198, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078457.611, "dur": 0.451, "name": "RLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078457.272, "dur": 3.199, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078456.833, "dur": 5.31, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:316)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078462.839, "dur": 0.692, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:46)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078464.079, "dur": 0.243, "name": "_queue.SimpleQueue.put", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078466.219, "dur": 0.207, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078465.939, "dur": 0.579, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078466.925, "dur": 0.339, "name": "time.monotonic", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078468.821, "dur": 0.452, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078468.544, "dur": 0.86, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078472.155, "dur": 0.098, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078472.376, "dur": 0.101, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078473.24, "dur": 0.181, "name": "collections.deque.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078473.977, "dur": 0.116, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078473.752, "dur": 0.406, "name": "_release_save (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:255)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078474.494, "dur": 0.318, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078475.44, "dur": 0.108, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078475.231, "dur": 0.384, "name": "_acquire_restore (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:258)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078476.106, "dur": 0.339, "name": "collections.deque.remove", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078468.182, "dur": 8.443, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:270)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078477.174, "dur": 0.139, "name": "time.monotonic", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078478.276, "dur": 0.096, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078478.02, "dur": 0.433, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078465.316, "dur": 13.319, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:394)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078479.359, "dur": 0.158, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078484.982, "dur": 0.121, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078484.747, "dur": 0.765, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078486.382, "dur": 0.326, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1095)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078488.395, "dur": 0.093, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078488.724, "dur": 3.172, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078488.141, "dur": 4.509, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:505)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078494.753, "dur": 1.135, "name": "_make_invoke_excepthook (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1177)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078497.546, "dur": 0.19, "name": "set.add", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078496.612, "dur": 1.235, "name": "add (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078482.821, "dur": 15.127, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:761)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078502.11, "dur": 0.216, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078498.764, "dur": 3.851, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1110)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078503.485, "dur": 0.087, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078505.194, "dur": 44.098, "name": "_thread.start_new_thread", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078551.264, "dur": 0.397, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078551.049, "dur": 0.693, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078552.523, "dur": 0.286, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078552.38, "dur": 0.543, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078553.12, "dur": 0.727, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078553.97, "dur": 0.093, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078554.327, "dur": 0.085, "name": "collections.deque.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078554.821, "dur": 0.089, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078554.644, "dur": 0.336, "name": "_release_save (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:255)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091736.337, "dur": 3.518, "name": "_queue.SimpleQueue.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091744.719, "dur": 0.54, "name": "_thread.RLock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091743.964, "dur": 1.694, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091747.314, "dur": 0.198, "name": "_thread.RLock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091746.955, "dur": 0.638, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091743.32, "dur": 4.561, "name": "set_running_or_notify_cancel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:477)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091751.346, "dur": 0.827, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091756.245, "dur": 0.078, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091756.062, "dur": 2.638, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091759.142, "dur": 0.174, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091760.647, "dur": 0.798, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091762.265, "dur": 0.065, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091762.158, "dur": 0.274, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091768.555, "dur": 0.144, "name": "ident (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1047)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091771.25, "dur": 5.478, "name": "type.now", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091755.269, "dur": 21.857, "name": "__init__ (/home/edx/PycharmProjects/examples/threads/utils.py:22)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091786.862, "dur": 0.155, "name": "dict.items", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091790.097, "dur": 1.897, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091789.518, "dur": 2.584, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091792.41, "dur": 7.4, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091792.201, "dur": 7.692, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091800.108, "dur": 0.475, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091799.996, "dur": 0.63, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091800.8, "dur": 54.946, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091800.703, "dur": 55.353, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091856.554, "dur": 0.358, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091788.245, "dur": 70.441, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091859.857, "dur": 2.963, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091784.939, "dur": 78.02, "name": "__repr__ (/home/edx/PycharmProjects/examples/threads/utils.py:28)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091779.068, "dur": 86.047, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091868.723, "dur": 0.395, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091872.819, "dur": 2.683, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091879.132, "dur": 0.272, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091878.465, "dur": 1.043, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091881.539, "dur": 0.835, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091886.044, "dur": 0.619, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091885.265, "dur": 1.442, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091887.048, "dur": 0.066, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091887.48, "dur": 0.054, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091887.398, "dur": 0.182, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091877.764, "dur": 11.28, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091892.272, "dur": 0.482, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091897.94, "dur": 0.449, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091897.252, "dur": 1.276, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091900.332, "dur": 0.052, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091901.382, "dur": 0.782, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091900.905, "dur": 1.433, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091902.791, "dur": 1.363, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091900.182, "dur": 5.593, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091907.057, "dur": 0.033, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091907.235, "dur": 0.121, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091908.315, "dur": 0.176, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091908.622, "dur": 0.219, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091908.136, "dur": 1.797, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091906.773, "dur": 3.29, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091916.43, "dur": 0.194, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091917.333, "dur": 0.048, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091917.191, "dur": 0.504, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091917.999, "dur": 0.291, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091918.996, "dur": 0.44, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091921.607, "dur": 0.553, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091922.919, "dur": 0.387, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091923.608, "dur": 0.314, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091924.045, "dur": 0.479, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091891.478, "dur": 33.181, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091890.128, "dur": 35.109, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091926.39, "dur": 0.858, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091929.898, "dur": 0.229, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091931.039, "dur": 0.639, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091930.495, "dur": 1.282, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091934.478, "dur": 1.04, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091937.742, "dur": 0.343, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091937.224, "dur": 1.043, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091936.358, "dur": 1.99, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091939.399, "dur": 4.964, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091944.976, "dur": 5.014, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091938.911, "dur": 11.238, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091952.044, "dur": 6.232, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091951.633, "dur": 6.806, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091951.201, "dur": 7.358, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091933.9, "dur": 24.987, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091932.994, "dur": 26.046, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091960.858, "dur": 9.507, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091971.601, "dur": 0.321, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091971.345, "dur": 0.651, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091972.322, "dur": 0.363, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091972.879, "dur": 1.529, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091974.882, "dur": 0.09, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091974.682, "dur": 0.346, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091970.938, "dur": 4.209, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091932.539, "dur": 42.71, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091975.633, "dur": 0.098, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091975.505, "dur": 0.284, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091929.617, "dur": 46.252, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091927.591, "dur": 48.866, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091925.764, "dur": 50.823, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091876.384, "dur": 100.304, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091871.635, "dur": 106.264, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091866.474, "dur": 111.63, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091979.591, "dur": 0.094, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091980.977, "dur": 0.321, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091983.937, "dur": 0.164, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091983.683, "dur": 0.471, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091984.63, "dur": 0.094, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091985.627, "dur": 0.073, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091985.481, "dur": 0.263, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091986.02, "dur": 0.08, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091986.414, "dur": 0.035, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091986.332, "dur": 0.153, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091983.436, "dur": 3.692, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091988.416, "dur": 0.167, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091989.085, "dur": 0.106, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091992.1, "dur": 2.112, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091991.669, "dur": 2.644, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091990.715, "dur": 3.769, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091995.097, "dur": 0.124, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091994.903, "dur": 0.426, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091995.982, "dur": 0.046, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091996.666, "dur": 0.206, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091996.503, "dur": 0.438, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091997.138, "dur": 0.383, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091995.878, "dur": 2.063, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091998.541, "dur": 0.047, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091998.684, "dur": 0.076, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091999.341, "dur": 0.146, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091999.612, "dur": 0.132, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091999.241, "dur": 1.263, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091998.446, "dur": 2.161, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092002.49, "dur": 0.159, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092003.132, "dur": 0.05, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092003.009, "dur": 0.406, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092003.612, "dur": 0.191, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092004.197, "dur": 0.114, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092004.81, "dur": 0.104, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092005.16, "dur": 0.109, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092005.539, "dur": 0.145, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092005.801, "dur": 0.307, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091988.261, "dur": 17.992, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091987.695, "dur": 18.977, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092007.251, "dur": 0.253, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092008.513, "dur": 0.172, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092009.073, "dur": 0.207, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092008.892, "dur": 0.449, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092010.233, "dur": 1.463, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092012.46, "dur": 0.28, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092012.252, "dur": 0.583, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092011.974, "dur": 0.939, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092013.389, "dur": 1.644, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092016.823, "dur": 1.37, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092013.19, "dur": 5.143, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092019.515, "dur": 1.601, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092019.367, "dur": 1.885, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092018.887, "dur": 2.447, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092010.031, "dur": 11.534, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092009.718, "dur": 11.939, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092022.441, "dur": 2.049, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092025.062, "dur": 0.187, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092024.888, "dur": 0.418, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092025.547, "dur": 0.157, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092025.854, "dur": 0.435, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092026.599, "dur": 0.055, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092026.472, "dur": 0.23, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092024.697, "dur": 2.098, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092009.544, "dur": 17.35, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092027.238, "dur": 0.065, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092027.119, "dur": 0.244, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092008.368, "dur": 19.069, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092007.697, "dur": 20.22, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092006.979, "dur": 21.056, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091983.132, "dur": 45.006, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091980.549, "dur": 48.307, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091979.392, "dur": 49.709, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078555.225, "dur": 13481.844, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092038.51, "dur": 0.22, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092038.236, "dur": 0.548, "name": "_acquire_restore (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:258)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078552.184, "dur": 13486.799, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:270)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092040.423, "dur": 0.1, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092040.196, "dur": 0.401, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078550.528, "dur": 13490.247, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:540)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078503.16, "dur": 13538.059, "name": "start (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:834)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092043.034, "dur": 0.381, "name": "set.add", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092045.546, "dur": 1.667, "name": "__setitem__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:395)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078464.69, "dur": 13582.672, "name": "_adjust_thread_count (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:193)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439078453.469, "dur": 13594.848, "name": "submit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:158)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092050.133, "dur": 0.138, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092054.563, "dur": 0.582, "name": "RLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092053.774, "dur": 3.973, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092053.139, "dur": 5.524, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:316)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092059.207, "dur": 0.582, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:46)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092060.273, "dur": 0.361, "name": "_queue.SimpleQueue.put", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092062.255, "dur": 0.335, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092062.064, "dur": 0.589, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092063.068, "dur": 0.273, "name": "time.monotonic", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092064.369, "dur": 0.407, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092064.217, "dur": 0.653, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092067.17, "dur": 0.421, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092067.711, "dur": 0.145, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092068.328, "dur": 0.142, "name": "collections.deque.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092068.771, "dur": 0.094, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092068.649, "dur": 0.267, "name": "_release_save (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:255)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092069.186, "dur": 0.223, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092069.731, "dur": 0.098, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092069.643, "dur": 0.234, "name": "_acquire_restore (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:258)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092070.071, "dur": 0.162, "name": "collections.deque.remove", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092063.969, "dur": 6.413, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:270)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092070.848, "dur": 0.073, "name": "time.monotonic", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092071.996, "dur": 0.061, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092071.803, "dur": 0.329, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092061.629, "dur": 10.634, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:394)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092072.991, "dur": 0.245, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092078.642, "dur": 0.102, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092078.485, "dur": 0.68, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092079.639, "dur": 0.537, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1095)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092081.235, "dur": 0.101, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092081.569, "dur": 4.794, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092081.0, "dur": 5.803, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:505)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092088.211, "dur": 1.202, "name": "_make_invoke_excepthook (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1177)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092100.395, "dur": 0.181, "name": "set.add", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092090.5, "dur": 10.369, "name": "add (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092076.95, "dur": 24.06, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:761)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092102.832, "dur": 0.183, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092101.873, "dur": 1.322, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1110)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092103.807, "dur": 0.057, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092105.44, "dur": 34.655, "name": "_thread.start_new_thread", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092141.557, "dur": 0.235, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092141.38, "dur": 0.503, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092142.657, "dur": 0.3, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092142.527, "dur": 0.521, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092143.213, "dur": 0.396, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092143.697, "dur": 0.083, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092143.942, "dur": 0.093, "name": "collections.deque.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092144.323, "dur": 0.087, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092144.194, "dur": 0.273, "name": "_release_save (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:255)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092181.985, "dur": 0.454, "name": "_queue.SimpleQueue.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092183.811, "dur": 0.287, "name": "_thread.RLock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092183.606, "dur": 0.578, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092185.081, "dur": 0.115, "name": "_thread.RLock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092184.89, "dur": 0.37, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092183.266, "dur": 2.139, "name": "set_running_or_notify_cancel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:477)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092186.773, "dur": 0.234, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092188.409, "dur": 0.083, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092188.272, "dur": 1.662, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092190.31, "dur": 0.146, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092190.793, "dur": 0.248, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092191.408, "dur": 0.06, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092191.304, "dur": 0.253, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092191.766, "dur": 0.116, "name": "ident (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1047)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092192.416, "dur": 1.363, "name": "type.now", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092187.83, "dur": 6.169, "name": "__init__ (/home/edx/PycharmProjects/examples/threads/utils.py:22)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092196.773, "dur": 0.157, "name": "dict.items", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092198.376, "dur": 0.951, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092198.072, "dur": 1.338, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092199.673, "dur": 2.133, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092199.51, "dur": 2.367, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092202.117, "dur": 0.382, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092201.989, "dur": 0.559, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092202.717, "dur": 2.511, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092202.617, "dur": 2.674, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092205.358, "dur": 0.097, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092197.526, "dur": 8.923, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092206.71, "dur": 1.368, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092196.112, "dur": 12.074, "name": "__repr__ (/home/edx/PycharmProjects/examples/threads/utils.py:28)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092194.836, "dur": 14.252, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092209.762, "dur": 0.161, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092211.194, "dur": 0.394, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092212.985, "dur": 0.17, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092212.745, "dur": 0.472, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092213.757, "dur": 0.132, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092214.774, "dur": 0.105, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092214.603, "dur": 0.314, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092215.193, "dur": 0.066, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092215.594, "dur": 0.041, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092215.509, "dur": 0.17, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092212.532, "dur": 3.726, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092217.529, "dur": 0.188, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092220.115, "dur": 0.166, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092219.896, "dur": 0.482, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092221.366, "dur": 0.05, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092221.794, "dur": 0.282, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092221.585, "dur": 0.573, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092222.323, "dur": 0.521, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092221.261, "dur": 2.184, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092224.049, "dur": 0.045, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092224.209, "dur": 0.106, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092224.758, "dur": 0.17, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092225.035, "dur": 0.118, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092224.642, "dur": 1.282, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092223.937, "dur": 2.093, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092229.505, "dur": 0.175, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092230.205, "dur": 0.059, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092230.087, "dur": 0.399, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092230.694, "dur": 0.186, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092231.29, "dur": 0.195, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092232.097, "dur": 0.087, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092232.403, "dur": 0.13, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092232.789, "dur": 0.155, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092233.068, "dur": 0.263, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092217.313, "dur": 16.131, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092216.766, "dur": 17.12, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092234.533, "dur": 0.343, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092235.934, "dur": 0.108, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092236.411, "dur": 0.285, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092236.245, "dur": 0.544, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092237.751, "dur": 0.607, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092239.13, "dur": 0.339, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092238.854, "dur": 0.729, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092238.626, "dur": 1.031, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092240.239, "dur": 2.121, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092242.61, "dur": 2.968, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092239.995, "dur": 5.72, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092246.706, "dur": 3.483, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092246.528, "dur": 3.811, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092246.362, "dur": 4.088, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092237.575, "dur": 13.18, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092237.222, "dur": 13.652, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092144.689, "dur": 113.679, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092258.881, "dur": 0.218, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092258.752, "dur": 0.404, "name": "_acquire_restore (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:258)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092142.336, "dur": 116.985, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:270)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092260.199, "dur": 0.096, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092259.982, "dur": 0.367, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092140.997, "dur": 119.559, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:540)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092103.52, "dur": 157.212, "name": "start (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:834)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092261.143, "dur": 0.114, "name": "set.add", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092261.822, "dur": 0.764, "name": "__setitem__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:395)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092060.873, "dur": 201.788, "name": "_adjust_thread_count (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:193)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092049.792, "dur": 213.163, "name": "submit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:158)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092263.823, "dur": 0.133, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092266.515, "dur": 0.458, "name": "RLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092266.175, "dur": 2.546, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092265.745, "dur": 3.691, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:316)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092269.895, "dur": 0.325, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:46)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092270.492, "dur": 0.171, "name": "_queue.SimpleQueue.put", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092271.714, "dur": 0.188, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092271.548, "dur": 2.04, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092273.963, "dur": 0.189, "name": "time.monotonic", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092274.898, "dur": 0.322, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092274.785, "dur": 0.508, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092275.409, "dur": 0.345, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092275.852, "dur": 0.087, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092276.081, "dur": 0.07, "name": "collections.deque.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092276.43, "dur": 0.09, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092276.315, "dur": 0.257, "name": "_release_save (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:255)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092276.824, "dur": 0.157, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092277.304, "dur": 0.076, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092277.208, "dur": 0.215, "name": "_acquire_restore (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:258)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092277.622, "dur": 0.076, "name": "collections.deque.remove", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092274.629, "dur": 3.15, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:270)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092278.166, "dur": 0.069, "name": "time.monotonic", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092278.958, "dur": 0.044, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092278.795, "dur": 0.253, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092271.246, "dur": 7.954, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:394)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092279.879, "dur": 0.137, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092283.84, "dur": 0.094, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092283.719, "dur": 0.427, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092284.366, "dur": 0.129, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1095)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092285.194, "dur": 0.08, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092285.486, "dur": 3.558, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092285.081, "dur": 4.269, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:505)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092290.121, "dur": 0.602, "name": "_make_invoke_excepthook (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1177)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092291.649, "dur": 0.145, "name": "set.add", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092291.074, "dur": 0.834, "name": "add (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:81)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092282.558, "dur": 9.435, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:761)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092292.846, "dur": 0.104, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092292.573, "dur": 0.536, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1110)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092293.499, "dur": 0.071, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092294.452, "dur": 19.157, "name": "_thread.start_new_thread", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092314.867, "dur": 0.185, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092314.714, "dur": 0.407, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092315.825, "dur": 0.258, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092315.691, "dur": 0.463, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092316.305, "dur": 0.189, "name": "_thread.allocate_lock", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092316.561, "dur": 0.089, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092316.833, "dur": 0.067, "name": "collections.deque.append", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092317.203, "dur": 0.103, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092317.063, "dur": 0.295, "name": "_release_save (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:255)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092251.912, "dur": 69.897, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092322.817, "dur": 0.205, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092322.576, "dur": 0.511, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092323.426, "dur": 0.353, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092323.936, "dur": 0.573, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092326.381, "dur": 0.099, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092326.211, "dur": 0.332, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092322.422, "dur": 4.235, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092237.036, "dur": 89.725, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092327.177, "dur": 0.125, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092327.072, "dur": 0.283, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092235.785, "dur": 91.668, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092235.065, "dur": 93.033, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092234.277, "dur": 93.945, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092212.089, "dur": 116.235, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092210.919, "dur": 118.393, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092209.438, "dur": 120.105, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092359.481, "dur": 0.395, "name": "_queue.SimpleQueue.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092361.193, "dur": 0.274, "name": "_thread.RLock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092361.031, "dur": 0.505, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092362.343, "dur": 0.109, "name": "_thread.RLock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092362.183, "dur": 0.323, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092360.714, "dur": 1.932, "name": "set_running_or_notify_cancel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:477)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092363.567, "dur": 0.201, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092364.899, "dur": 0.105, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092364.764, "dur": 0.351, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092365.415, "dur": 0.136, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092365.843, "dur": 0.274, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092366.447, "dur": 0.057, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092366.349, "dur": 0.248, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092366.832, "dur": 0.128, "name": "ident (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1047)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092367.372, "dur": 1.214, "name": "type.now", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092364.466, "dur": 4.283, "name": "__init__ (/home/edx/PycharmProjects/examples/threads/utils.py:22)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092370.854, "dur": 0.078, "name": "dict.items", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092372.268, "dur": 0.9, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092371.993, "dur": 1.243, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092373.478, "dur": 1.863, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092373.313, "dur": 2.115, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092375.637, "dur": 0.459, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092375.528, "dur": 0.618, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092376.299, "dur": 2.424, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092376.214, "dur": 2.568, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092378.85, "dur": 0.089, "name": "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092371.471, "dur": 8.283, "name": "str.join", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092379.981, "dur": 1.158, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092370.288, "dur": 10.955, "name": "__repr__ (/home/edx/PycharmProjects/examples/threads/utils.py:28)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092369.326, "dur": 12.735, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092382.65, "dur": 0.159, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092383.969, "dur": 0.38, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092385.546, "dur": 0.196, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092385.29, "dur": 0.515, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092387.54, "dur": 0.107, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092388.38, "dur": 0.098, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092388.209, "dur": 0.31, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092388.813, "dur": 0.069, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092389.241, "dur": 0.055, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092389.149, "dur": 0.183, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092385.139, "dur": 4.817, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092391.202, "dur": 0.171, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092393.334, "dur": 0.156, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092393.124, "dur": 0.486, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092394.421, "dur": 0.054, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092394.845, "dur": 0.293, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092394.659, "dur": 0.571, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092395.405, "dur": 0.462, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092394.304, "dur": 2.203, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092397.048, "dur": 0.047, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092397.209, "dur": 0.121, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092397.768, "dur": 0.137, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092398.051, "dur": 0.129, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092397.629, "dur": 1.324, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092396.949, "dur": 2.12, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092401.169, "dur": 0.104, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092401.775, "dur": 0.043, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092401.675, "dur": 0.329, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092402.201, "dur": 0.142, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092402.729, "dur": 0.151, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092403.398, "dur": 0.135, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092403.739, "dur": 0.111, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092404.108, "dur": 0.143, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092404.384, "dur": 0.264, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092391.048, "dur": 13.733, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092390.464, "dur": 14.724, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092405.743, "dur": 0.296, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092407.123, "dur": 0.112, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092407.626, "dur": 0.278, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092407.453, "dur": 0.54, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092408.93, "dur": 0.541, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092411.459, "dur": 0.346, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092409.97, "dur": 1.984, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092409.728, "dur": 2.341, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092412.593, "dur": 2.034, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092414.862, "dur": 2.728, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092412.366, "dur": 5.348, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092418.751, "dur": 3.447, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092418.571, "dur": 3.79, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092418.403, "dur": 4.067, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092408.736, "dur": 13.994, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092408.4, "dur": 15.384, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092317.57, "dur": 113.201, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092431.353, "dur": 0.239, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092431.188, "dur": 0.459, "name": "_acquire_restore (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:258)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092315.53, "dur": 116.283, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:270)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092432.696, "dur": 0.089, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092432.461, "dur": 0.387, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092314.383, "dur": 118.64, "name": "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:540)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092293.297, "dur": 139.882, "name": "start (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:834)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092433.516, "dur": 0.121, "name": "set.add", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092434.152, "dur": 0.696, "name": "__setitem__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:395)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092270.847, "dur": 164.091, "name": "_adjust_thread_count (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:193)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092263.64, "dur": 171.629, "name": "submit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:158)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092439.379, "dur": 0.212, "name": "_queue.SimpleQueue.put", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092440.914, "dur": 0.115, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092441.405, "dur": 0.131, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092441.273, "dur": 0.445, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092424.734, "dur": 21.512, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092447.004, "dur": 0.166, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092446.756, "dur": 0.493, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092447.54, "dur": 0.263, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092447.941, "dur": 0.505, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092448.743, "dur": 0.091, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092448.62, "dur": 0.266, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092446.578, "dur": 2.42, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092408.205, "dur": 40.891, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092449.53, "dur": 0.087, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092449.421, "dur": 0.247, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092406.981, "dur": 42.795, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092406.239, "dur": 44.034, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092405.51, "dur": 44.886, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092384.768, "dur": 65.731, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092383.76, "dur": 67.657, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092382.334, "dur": 69.288, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439092030.205, "dur": 100859.29, "name": "time.sleep", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192931.661, "dur": 2.239, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192946.97, "dur": 4.653, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192961.781, "dur": 2.438, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192959.704, "dur": 4.885, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192971.865, "dur": 1.736, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192988.148, "dur": 1.37, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192986.531, "dur": 3.423, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192991.177, "dur": 0.26, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192992.935, "dur": 0.109, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192992.61, "dur": 0.553, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192958.047, "dur": 38.732, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193032.756, "dur": 1.669, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193037.604, "dur": 0.437, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193046.874, "dur": 6.628, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193045.633, "dur": 8.128, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193042.341, "dur": 12.238, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193058.024, "dur": 1.205, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193056.354, "dur": 3.482, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193063.568, "dur": 0.196, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193065.542, "dur": 1.026, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193064.702, "dur": 2.155, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193067.924, "dur": 4.251, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193063.025, "dur": 13.151, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193079.235, "dur": 0.187, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193079.828, "dur": 0.358, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193082.316, "dur": 0.669, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193083.494, "dur": 0.533, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193081.88, "dur": 6.017, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193078.607, "dur": 9.681, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193101.894, "dur": 1.036, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193106.604, "dur": 0.376, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193105.658, "dur": 2.602, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193110.356, "dur": 1.533, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193113.762, "dur": 1.557, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193118.814, "dur": 1.089, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193121.442, "dur": 0.892, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193123.57, "dur": 0.885, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193124.864, "dur": 3.012, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193030.253, "dur": 98.155, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193025.11, "dur": 105.506, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193133.432, "dur": 2.548, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193141.809, "dur": 0.507, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193144.461, "dur": 3.954, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193143.203, "dur": 5.569, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193153.909, "dur": 10.199, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193169.212, "dur": 1.558, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193167.645, "dur": 3.505, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193165.767, "dur": 5.597, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193173.585, "dur": 17.482, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193192.192, "dur": 9.001, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193172.598, "dur": 28.959, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193206.008, "dur": 10.813, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193205.302, "dur": 11.911, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193203.84, "dur": 13.683, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193152.82, "dur": 65.584, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193150.711, "dur": 68.055, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193223.463, "dur": 18.75, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193244.575, "dur": 0.821, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193243.891, "dur": 8.56, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193253.663, "dur": 1.043, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193255.254, "dur": 2.629, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193259.643, "dur": 0.33, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193258.868, "dur": 1.344, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193243.234, "dur": 17.386, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193149.804, "dur": 111.308, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193262.263, "dur": 0.335, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193261.88, "dur": 0.902, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193141.066, "dur": 122.01, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193136.798, "dur": 128.264, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193132.009, "dur": 133.483, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192954.478, "dur": 311.393, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192944.695, "dur": 325.125, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439192927.447, "dur": 343.106, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193272.871, "dur": 4.959, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193279.404, "dur": 0.463, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193283.377, "dur": 1.322, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193288.398, "dur": 0.583, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193287.666, "dur": 1.461, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193290.458, "dur": 0.371, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193293.412, "dur": 0.364, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193292.943, "dur": 0.973, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193294.839, "dur": 0.218, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193296.246, "dur": 0.113, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193295.992, "dur": 0.482, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193287.094, "dur": 11.125, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193302.137, "dur": 0.483, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193305.157, "dur": 0.414, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193304.589, "dur": 1.357, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193308.244, "dur": 0.131, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193309.438, "dur": 0.675, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193308.891, "dur": 1.463, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193310.796, "dur": 1.036, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193307.918, "dur": 5.378, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193315.021, "dur": 0.156, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193315.568, "dur": 0.357, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193317.291, "dur": 0.489, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193318.212, "dur": 0.382, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193316.938, "dur": 3.99, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193314.662, "dur": 6.617, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193326.85, "dur": 0.5, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193329.517, "dur": 0.191, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193329.002, "dur": 1.403, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193331.219, "dur": 0.751, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193333.291, "dur": 0.41, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193340.608, "dur": 0.475, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193341.648, "dur": 0.426, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193342.94, "dur": 0.44, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193343.794, "dur": 0.808, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193301.541, "dur": 43.465, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193299.938, "dur": 46.295, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193347.982, "dur": 0.856, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193352.053, "dur": 0.438, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193353.674, "dur": 0.923, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193353.139, "dur": 1.76, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193357.403, "dur": 1.849, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193361.744, "dur": 0.819, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193360.958, "dur": 1.897, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193360.227, "dur": 2.897, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193364.67, "dur": 5.865, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193371.327, "dur": 4.166, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193363.989, "dur": 11.868, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193378.58, "dur": 5.891, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193378.047, "dur": 6.827, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193377.538, "dur": 7.578, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193356.884, "dur": 29.026, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193356.085, "dur": 30.141, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193388.732, "dur": 6.415, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193397.024, "dur": 0.495, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193396.436, "dur": 1.352, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193398.61, "dur": 0.568, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193399.578, "dur": 1.4, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193402.008, "dur": 0.204, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193401.607, "dur": 0.79, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193395.911, "dur": 6.819, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193355.508, "dur": 47.494, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193404.125, "dur": 0.289, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193403.7, "dur": 0.903, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193351.637, "dur": 53.235, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193349.447, "dur": 56.841, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193347.155, "dur": 59.476, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193286.143, "dur": 120.813, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193282.659, "dur": 126.747, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193278.808, "dur": 131.189, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091753.422, "dur": 101657.221, "name": "update (/home/edx/PycharmProjects/examples/threads/race_conditions.py:17)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193414.702, "dur": 0.896, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193490.463, "dur": 25.708, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091750.056, "dur": 101767.215, "name": "timeit_wrapper (/home/edx/PycharmProjects/examples/threads/utils.py:10)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193529.382, "dur": 2.146, "name": "_thread.RLock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193527.962, "dur": 3.9, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193541.787, "dur": 1.208, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193544.915, "dur": 0.52, "name": "_thread.RLock._is_owned", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193543.93, "dur": 17.738, "name": "notify (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:341)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193540.308, "dur": 22.432, "name": "notify_all (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:364)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193565.948, "dur": 0.81, "name": "_thread.RLock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193564.818, "dur": 2.291, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193570.567, "dur": 1.313, "name": "_invoke_callbacks (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:325)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193525.102, "dur": 47.11, "name": "set_result (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:517)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091740.834, "dur": 101832.148, "name": "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193582.94, "dur": 1.058, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193582.127, "dur": 2.069, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193588.154, "dur": 26.524, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193587.344, "dur": 28.478, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193586.796, "dur": 35.108, "name": "notify (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:341)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193625.431, "dur": 0.565, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193624.291, "dur": 2.078, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193581.205, "dur": 45.821, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:441)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193629.121, "dur": 2.462, "name": "_queue.SimpleQueue.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193635.678, "dur": 0.808, "name": "_queue.SimpleQueue.put", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091734.894, "dur": 101901.973, "name": "_worker (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:66)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439091732.654, "dur": 101910.204, "name": "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:859)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7727, "ts": 10439193646.914, "dur": 0.585, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194847.768, "dur": 1.68, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194856.969, "dur": 2.162, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194864.989, "dur": 1.078, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194863.922, "dur": 2.339, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194868.754, "dur": 0.571, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194872.902, "dur": 0.551, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194872.22, "dur": 1.458, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194874.672, "dur": 0.255, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194876.17, "dur": 0.132, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194875.928, "dur": 0.486, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194862.911, "dur": 15.686, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194884.455, "dur": 1.099, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194899.879, "dur": 0.383, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194905.543, "dur": 4.198, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194904.949, "dur": 5.062, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194902.962, "dur": 7.641, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194912.836, "dur": 0.772, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194911.826, "dur": 2.302, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194916.432, "dur": 0.222, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194917.748, "dur": 0.628, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194917.24, "dur": 1.38, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194919.248, "dur": 2.36, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194916.06, "dur": 8.111, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194925.821, "dur": 0.156, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194926.279, "dur": 0.23, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194927.837, "dur": 0.514, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194928.829, "dur": 0.37, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194927.454, "dur": 9.63, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194925.441, "dur": 12.038, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194946.488, "dur": 0.841, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194949.712, "dur": 0.145, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194949.111, "dur": 1.801, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194952.092, "dur": 1.132, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194954.738, "dur": 0.735, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194957.485, "dur": 0.508, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194958.912, "dur": 0.472, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194960.373, "dur": 0.598, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194961.42, "dur": 2.284, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194883.315, "dur": 80.832, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194880.432, "dur": 85.414, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194967.897, "dur": 1.434, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194973.277, "dur": 0.501, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194975.243, "dur": 1.891, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194974.407, "dur": 3.036, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194980.309, "dur": 7.382, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194990.449, "dur": 1.203, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194989.632, "dur": 2.429, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194988.688, "dur": 3.623, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194994.087, "dur": 10.014, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195005.168, "dur": 5.43, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194993.282, "dur": 17.67, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195014.354, "dur": 7.117, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195013.857, "dur": 8.048, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195012.854, "dur": 9.272, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194979.733, "dur": 43.138, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194978.64, "dur": 44.52, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195026.222, "dur": 11.131, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195039.663, "dur": 0.542, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195038.929, "dur": 1.503, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195041.41, "dur": 0.881, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195042.858, "dur": 1.738, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195045.772, "dur": 0.28, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195045.371, "dur": 0.837, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195038.32, "dur": 8.274, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194978.102, "dur": 68.861, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195048.199, "dur": 0.312, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195047.856, "dur": 0.798, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194972.751, "dur": 76.178, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194969.959, "dur": 80.706, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194966.954, "dur": 84.139, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194861.198, "dur": 190.229, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194855.895, "dur": 198.717, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439194845.505, "dur": 209.792, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092442.523, "dur": 102640.737, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195084.731, "dur": 0.24, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195088.356, "dur": 0.214, "name": "_thread.lock.locked", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195090.494, "dur": 0.766, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1095)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195086.838, "dur": 4.851, "name": "_stop (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:944)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092442.324, "dur": 102649.72, "name": "_wait_for_tstate_lock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1017)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092440.426, "dur": 102653.156, "name": "join (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:979)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195097.731, "dur": 0.493, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195099.526, "dur": 0.549, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195098.895, "dur": 2.435, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439195064.93, "dur": 105336.311, "name": "time.sleep", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300427.209, "dur": 1.364, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300437.399, "dur": 2.839, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300446.553, "dur": 1.3, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300444.828, "dur": 3.191, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300450.536, "dur": 0.554, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300455.913, "dur": 0.589, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300454.628, "dur": 2.14, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300457.453, "dur": 0.178, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300458.378, "dur": 0.062, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300458.249, "dur": 0.246, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300443.792, "dur": 17.263, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300466.79, "dur": 1.296, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300470.155, "dur": 0.205, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300475.594, "dur": 4.846, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300475.004, "dur": 5.582, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300473.0, "dur": 7.98, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300482.938, "dur": 0.646, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300481.95, "dur": 1.947, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300486.038, "dur": 0.097, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300487.195, "dur": 0.591, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300486.624, "dur": 1.306, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300488.555, "dur": 2.221, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300485.778, "dur": 7.611, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300495.805, "dur": 0.077, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300496.052, "dur": 0.141, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300499.431, "dur": 0.256, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300499.91, "dur": 0.644, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300499.046, "dur": 4.565, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300495.355, "dur": 8.44, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300520.171, "dur": 0.619, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300523.446, "dur": 0.074, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300522.773, "dur": 1.588, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300525.535, "dur": 1.138, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300527.813, "dur": 0.718, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300531.074, "dur": 0.6, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300532.622, "dur": 0.542, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300549.135, "dur": 0.768, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300550.13, "dur": 1.481, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300465.547, "dur": 86.534, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300462.658, "dur": 90.497, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300554.924, "dur": 1.227, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300559.452, "dur": 0.259, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300561.058, "dur": 2.35, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300560.219, "dur": 3.339, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300566.543, "dur": 6.212, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300575.835, "dur": 0.863, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300574.83, "dur": 2.114, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300573.627, "dur": 3.43, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300578.27, "dur": 10.063, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300588.889, "dur": 5.264, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300577.742, "dur": 16.566, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300596.975, "dur": 7.24, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300596.572, "dur": 7.81, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300595.667, "dur": 8.861, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300565.817, "dur": 39.256, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300564.739, "dur": 40.51, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300608.364, "dur": 13.047, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300623.18, "dur": 0.396, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300622.832, "dur": 0.875, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300624.595, "dur": 0.463, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300625.302, "dur": 1.409, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300627.442, "dur": 0.126, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300627.253, "dur": 0.41, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300622.413, "dur": 5.415, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300564.171, "dur": 63.905, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300628.586, "dur": 0.184, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300628.422, "dur": 0.418, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300558.796, "dur": 70.176, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300556.596, "dur": 73.311, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300554.045, "dur": 76.067, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300441.726, "dur": 188.548, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300436.203, "dur": 195.971, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300424.006, "dur": 208.644, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300634.36, "dur": 2.823, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300637.94, "dur": 0.236, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300639.999, "dur": 0.56, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300642.375, "dur": 0.312, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300642.095, "dur": 0.703, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300643.519, "dur": 0.154, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300644.648, "dur": 0.136, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300644.439, "dur": 0.41, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300645.314, "dur": 0.092, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300649.127, "dur": 0.082, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300648.996, "dur": 0.273, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300641.8, "dur": 8.282, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300651.888, "dur": 0.237, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300653.419, "dur": 0.26, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300653.181, "dur": 0.642, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300654.864, "dur": 0.052, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300655.501, "dur": 0.412, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300655.223, "dur": 0.789, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300656.283, "dur": 0.482, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300654.702, "dur": 2.759, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300658.368, "dur": 0.05, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300658.563, "dur": 0.162, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300659.525, "dur": 0.203, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300659.895, "dur": 0.183, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300659.328, "dur": 1.833, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300658.228, "dur": 3.086, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300664.357, "dur": 0.207, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300665.633, "dur": 0.06, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300665.389, "dur": 0.668, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300666.483, "dur": 0.35, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300667.479, "dur": 0.195, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300668.321, "dur": 0.166, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300668.763, "dur": 0.163, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300669.336, "dur": 0.3, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300669.828, "dur": 0.386, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300651.644, "dur": 18.764, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300650.894, "dur": 20.092, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300671.862, "dur": 0.341, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300673.665, "dur": 0.247, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300674.449, "dur": 0.371, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300674.192, "dur": 0.734, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300676.249, "dur": 0.842, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300678.276, "dur": 0.425, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300677.929, "dur": 0.899, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300677.566, "dur": 1.38, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300679.69, "dur": 2.785, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300682.851, "dur": 2.041, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300679.336, "dur": 5.732, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300686.389, "dur": 2.718, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300686.152, "dur": 3.125, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300685.914, "dur": 3.478, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300675.947, "dur": 13.787, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300675.45, "dur": 14.428, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300690.937, "dur": 3.005, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300694.829, "dur": 0.197, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300694.571, "dur": 0.551, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300698.209, "dur": 0.311, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300698.726, "dur": 0.561, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300699.763, "dur": 0.081, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300699.568, "dur": 0.375, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300694.298, "dur": 5.836, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300675.21, "dur": 25.113, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300700.843, "dur": 0.143, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300700.676, "dur": 0.394, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300673.416, "dur": 27.801, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300672.511, "dur": 29.467, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300671.414, "dur": 30.755, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300641.348, "dur": 60.986, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300639.717, "dur": 63.782, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300637.651, "dur": 66.122, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092187.281, "dur": 208516.803, "name": "update (/home/edx/PycharmProjects/examples/threads/race_conditions.py:17)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300706.812, "dur": 0.432, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300726.104, "dur": 6.311, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092186.524, "dur": 208546.181, "name": "timeit_wrapper (/home/edx/PycharmProjects/examples/threads/utils.py:10)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300738.563, "dur": 0.481, "name": "_thread.RLock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300737.428, "dur": 1.713, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300744.387, "dur": 0.771, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300746.473, "dur": 0.243, "name": "_thread.RLock._is_owned", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300745.716, "dur": 4.423, "name": "notify (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:341)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300743.315, "dur": 7.301, "name": "notify_all (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:364)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300752.108, "dur": 0.219, "name": "_thread.RLock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300751.592, "dur": 0.905, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300753.369, "dur": 0.468, "name": "_invoke_callbacks (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:325)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300735.952, "dur": 18.099, "name": "set_result (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:517)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092182.772, "dur": 208571.679, "name": "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300759.408, "dur": 0.717, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300758.622, "dur": 1.588, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300762.246, "dur": 0.633, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300761.815, "dur": 1.204, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300761.541, "dur": 2.525, "name": "notify (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:341)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300764.698, "dur": 0.123, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300764.454, "dur": 0.445, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300758.146, "dur": 6.903, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:441)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300765.947, "dur": 1.597, "name": "_queue.SimpleQueue.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300769.211, "dur": 0.359, "name": "_queue.SimpleQueue.put", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092181.612, "dur": 208588.123, "name": "_worker (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:66)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439092180.751, "dur": 208592.44, "name": "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:859)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7728, "ts": 10439300775.473, "dur": 0.184, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301191.74, "dur": 0.51, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301195.803, "dur": 1.004, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301199.397, "dur": 0.494, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301198.909, "dur": 1.065, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301206.977, "dur": 0.262, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301209.311, "dur": 0.139, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301208.993, "dur": 0.562, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301210.022, "dur": 0.107, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301210.679, "dur": 0.074, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301210.569, "dur": 0.251, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301198.535, "dur": 13.627, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301216.658, "dur": 1.681, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301220.309, "dur": 0.191, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301230.963, "dur": 1.96, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301229.702, "dur": 3.337, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301226.957, "dur": 6.379, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301234.402, "dur": 0.65, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301233.941, "dur": 1.351, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301236.308, "dur": 0.082, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301236.979, "dur": 0.284, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301236.732, "dur": 0.644, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301237.646, "dur": 0.94, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301236.134, "dur": 3.566, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301240.559, "dur": 0.082, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301240.829, "dur": 0.135, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301241.712, "dur": 0.294, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301242.184, "dur": 0.171, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301241.503, "dur": 2.053, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301240.394, "dur": 3.305, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301247.22, "dur": 0.359, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301248.757, "dur": 0.065, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301248.482, "dur": 0.733, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301249.773, "dur": 0.62, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301250.973, "dur": 0.291, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301252.324, "dur": 0.349, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301253.064, "dur": 0.23, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301253.719, "dur": 0.277, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301254.192, "dur": 1.057, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301215.739, "dur": 39.727, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301213.279, "dur": 42.976, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301257.18, "dur": 0.541, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301259.391, "dur": 0.203, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301260.7, "dur": 0.867, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301260.26, "dur": 1.432, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301263.134, "dur": 3.138, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301267.919, "dur": 0.567, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301267.479, "dur": 1.209, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301266.906, "dur": 1.889, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301269.562, "dur": 4.471, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301274.444, "dur": 2.476, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301269.225, "dur": 7.873, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301281.474, "dur": 3.647, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301281.177, "dur": 4.13, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301280.57, "dur": 4.875, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301262.858, "dur": 22.965, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301262.413, "dur": 23.55, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301287.364, "dur": 4.317, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301292.589, "dur": 0.307, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301292.321, "dur": 0.67, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301293.388, "dur": 0.315, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301293.961, "dur": 0.644, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301295.175, "dur": 0.155, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301294.956, "dur": 0.45, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301292.093, "dur": 3.474, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301262.112, "dur": 33.59, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301296.218, "dur": 0.147, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301296.07, "dur": 0.359, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301259.164, "dur": 37.391, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301258.005, "dur": 39.363, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301256.783, "dur": 40.767, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301197.74, "dur": 99.964, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301195.28, "dur": 103.886, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301190.618, "dur": 108.927, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439301301.121, "dur": 100839.449, "name": "time.sleep", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402158.05, "dur": 1.486, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402166.216, "dur": 2.1, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402172.953, "dur": 1.299, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402171.97, "dur": 2.39, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402176.227, "dur": 0.459, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402180.44, "dur": 0.469, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402179.67, "dur": 1.751, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402181.885, "dur": 0.112, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402182.505, "dur": 0.035, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402182.391, "dur": 0.203, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402171.086, "dur": 13.185, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402189.338, "dur": 0.959, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402191.53, "dur": 0.17, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402195.908, "dur": 3.772, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402195.412, "dur": 4.361, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402193.836, "dur": 6.156, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402201.581, "dur": 0.494, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402200.745, "dur": 1.518, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402203.724, "dur": 0.055, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402204.824, "dur": 0.426, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402204.424, "dur": 0.947, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402205.857, "dur": 1.669, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402203.549, "dur": 5.784, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402219.904, "dur": 0.053, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402220.116, "dur": 0.129, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402221.253, "dur": 0.266, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402221.722, "dur": 0.229, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402221.064, "dur": 2.34, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402219.65, "dur": 3.874, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402230.237, "dur": 0.348, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402232.397, "dur": 0.05, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402231.883, "dur": 1.07, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402233.946, "dur": 1.057, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402235.863, "dur": 0.558, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402238.404, "dur": 1.915, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402241.188, "dur": 0.417, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402242.052, "dur": 0.797, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402242.998, "dur": 1.544, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402187.943, "dur": 56.782, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402185.517, "dur": 59.963, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402246.7, "dur": 1.418, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402251.663, "dur": 0.405, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402253.627, "dur": 1.658, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402252.556, "dur": 2.84, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402258.366, "dur": 4.627, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402265.776, "dur": 0.913, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402264.906, "dur": 2.004, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402263.765, "dur": 3.229, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402268.167, "dur": 11.69, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402280.526, "dur": 9.441, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402267.697, "dur": 22.381, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402293.18, "dur": 6.273, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402292.731, "dur": 6.845, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402291.97, "dur": 7.716, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402257.711, "dur": 42.324, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402256.395, "dur": 43.76, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402302.823, "dur": 8.387, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402312.244, "dur": 0.294, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402311.994, "dur": 0.623, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402313.325, "dur": 0.749, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402314.254, "dur": 1.534, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402317.551, "dur": 0.099, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402317.248, "dur": 0.462, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402311.716, "dur": 6.105, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402255.957, "dur": 62.117, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402318.422, "dur": 0.127, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402318.32, "dur": 0.272, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402251.37, "dur": 67.311, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402249.21, "dur": 70.139, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402246.026, "dur": 73.452, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402169.57, "dur": 152.8, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402165.148, "dur": 159.269, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402155.72, "dur": 169.089, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402328.456, "dur": 5.572, "name": "str.format", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402334.56, "dur": 0.139, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402335.756, "dur": 0.369, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402337.283, "dur": 0.196, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402337.094, "dur": 0.442, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402338.024, "dur": 0.111, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402338.815, "dur": 0.123, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402338.663, "dur": 0.316, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402339.215, "dur": 0.06, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402339.604, "dur": 0.035, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402339.524, "dur": 0.151, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402336.917, "dur": 3.198, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402341.346, "dur": 0.163, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402342.305, "dur": 0.141, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402342.148, "dur": 0.388, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402343.146, "dur": 0.06, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402343.512, "dur": 0.272, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402343.367, "dur": 0.479, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402344.005, "dur": 0.39, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402343.048, "dur": 1.754, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402345.319, "dur": 0.058, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402345.482, "dur": 0.114, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402345.991, "dur": 0.133, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402346.219, "dur": 0.115, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402345.887, "dur": 1.154, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402345.219, "dur": 1.93, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402348.797, "dur": 0.157, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402349.524, "dur": 0.042, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402349.409, "dur": 0.375, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402349.984, "dur": 0.206, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402350.583, "dur": 0.153, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402351.07, "dur": 0.116, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402351.362, "dur": 0.106, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402351.759, "dur": 0.143, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402352.045, "dur": 0.319, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402341.192, "dur": 11.316, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402340.635, "dur": 12.279, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402353.433, "dur": 0.234, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402354.742, "dur": 0.108, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402355.207, "dur": 0.223, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402355.036, "dur": 0.454, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402356.301, "dur": 0.623, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402357.619, "dur": 0.227, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402357.433, "dur": 1.912, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402357.203, "dur": 2.231, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402360.046, "dur": 20.256, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402380.616, "dur": 1.404, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402359.757, "dur": 22.363, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402383.104, "dur": 1.942, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402382.936, "dur": 2.264, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402382.743, "dur": 2.558, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402356.145, "dur": 29.481, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402355.853, "dur": 29.889, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402386.571, "dur": 15.288, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402402.408, "dur": 0.201, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402402.241, "dur": 0.422, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402402.942, "dur": 0.179, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402403.27, "dur": 0.364, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402403.951, "dur": 0.049, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402403.83, "dur": 0.227, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402402.065, "dur": 2.098, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402355.692, "dur": 48.574, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402404.582, "dur": 0.081, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402404.483, "dur": 0.231, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402354.578, "dur": 50.228, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402353.863, "dur": 51.422, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402353.22, "dur": 52.178, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402336.603, "dur": 68.918, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402335.595, "dur": 70.68, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402334.355, "dur": 72.118, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092364.044, "dur": 310042.62, "name": "update (/home/edx/PycharmProjects/examples/threads/race_conditions.py:17)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402408.758, "dur": 0.378, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402422.71, "dur": 4.423, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092363.283, "dur": 310064.044, "name": "timeit_wrapper (/home/edx/PycharmProjects/examples/threads/utils.py:10)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402430.838, "dur": 0.384, "name": "_thread.RLock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402430.314, "dur": 0.965, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402435.134, "dur": 0.538, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402436.548, "dur": 0.175, "name": "_thread.RLock._is_owned", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402436.076, "dur": 2.99, "name": "notify (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:341)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402434.504, "dur": 4.788, "name": "notify_all (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:364)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402440.486, "dur": 0.174, "name": "_thread.RLock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402440.093, "dur": 0.661, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402441.415, "dur": 0.404, "name": "_invoke_callbacks (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:325)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402429.341, "dur": 12.565, "name": "set_result (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:517)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092360.238, "dur": 310081.969, "name": "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402445.886, "dur": 0.326, "name": "_thread.lock.__enter__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402445.421, "dur": 0.843, "name": "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402448.13, "dur": 0.399, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402447.689, "dur": 0.931, "name": "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402447.483, "dur": 1.848, "name": "notify (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:341)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402451.544, "dur": 0.103, "name": "_thread.lock.__exit__", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402451.361, "dur": 0.337, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402445.036, "dur": 6.782, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:441)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402452.548, "dur": 0.896, "name": "_queue.SimpleQueue.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402454.575, "dur": 0.521, "name": "_queue.SimpleQueue.put", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092359.148, "dur": 310096.066, "name": "_worker (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:66)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439092358.36, "dur": 310099.293, "name": "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:859)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7729, "ts": 10439402459.351, "dur": 0.094, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195103.122, "dur": 207413.924, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402517.915, "dur": 0.118, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402518.947, "dur": 0.068, "name": "_thread.lock.locked", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402519.895, "dur": 0.344, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1095)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402518.519, "dur": 1.854, "name": "_stop (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:944)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195102.398, "dur": 207418.075, "name": "_wait_for_tstate_lock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1017)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439195095.999, "dur": 207425.102, "name": "join (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:979)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402523.485, "dur": 0.306, "name": "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402524.206, "dur": 0.112, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402524.062, "dur": 0.796, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402525.432, "dur": 0.75, "name": "_thread.lock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402526.258, "dur": 0.046, "name": "_thread.lock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402526.558, "dur": 0.04, "name": "_thread.lock.locked", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402526.843, "dur": 0.117, "name": "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1095)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402526.448, "dur": 0.582, "name": "_stop (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:944)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402525.228, "dur": 1.863, "name": "_wait_for_tstate_lock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1017)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402522.261, "dur": 5.011, "name": "join (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:979)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092438.595, "dur": 310088.879, "name": "shutdown (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:230)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439092437.719, "dur": 310090.494, "name": "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402529.725, "dur": 0.167, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402531.2, "dur": 0.298, "name": "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402532.729, "dur": 0.198, "name": "sys._getframe", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402532.536, "dur": 0.445, "name": "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402533.451, "dur": 0.15, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402534.472, "dur": 0.098, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402534.289, "dur": 0.326, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402534.906, "dur": 0.13, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402535.385, "dur": 0.032, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402535.304, "dur": 0.149, "name": "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402532.369, "dur": 3.75, "name": "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402537.38, "dur": 0.204, "name": "time.time", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402538.124, "dur": 0.084, "name": "builtins.len", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402539.266, "dur": 0.774, "name": "_abc._abc_instancecheck", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402539.165, "dur": 0.941, "name": "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402538.684, "dur": 1.616, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402540.778, "dur": 0.152, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402540.58, "dur": 0.46, "name": "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402541.694, "dur": 0.053, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402542.063, "dur": 0.171, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402541.915, "dur": 2.47, "name": "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402544.565, "dur": 0.48, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402541.579, "dur": 4.032, "name": "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402546.236, "dur": 0.048, "name": "posix.fspath", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402546.401, "dur": 0.088, "name": "builtins.isinstance", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402546.954, "dur": 0.166, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402547.258, "dur": 0.113, "name": "str.rfind", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402546.828, "dur": 1.289, "name": "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402546.12, "dur": 2.101, "name": "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402550.221, "dur": 0.098, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402550.882, "dur": 0.046, "name": "_thread.get_ident", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402550.758, "dur": 0.353, "name": "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402551.706, "dur": 0.571, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402552.687, "dur": 0.25, "name": "dict.get", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402553.426, "dur": 0.125, "name": "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402553.756, "dur": 0.164, "name": "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402554.226, "dur": 0.173, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402554.518, "dur": 0.462, "name": "posix.getpid", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402537.224, "dur": 17.879, "name": "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402536.592, "dur": 19.013, "name": "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402556.215, "dur": 0.28, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402557.575, "dur": 0.116, "name": "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402558.047, "dur": 0.276, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402557.866, "dur": 0.521, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402559.256, "dur": 2.146, "name": "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402562.191, "dur": 0.251, "name": "str.find", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402561.989, "dur": 0.575, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402561.721, "dur": 0.919, "name": "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402563.163, "dur": 2.605, "name": "time.localtime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402566.021, "dur": 4.077, "name": "time.strftime", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402562.899, "dur": 7.324, "name": "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402571.36, "dur": 1.825, "name": "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402571.197, "dur": 2.121, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402570.854, "dur": 2.548, "name": "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402559.103, "dur": 14.542, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402558.773, "dur": 14.968, "name": "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402574.635, "dur": 1.973, "name": "_io.TextIOWrapper.write", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402577.134, "dur": 0.189, "name": "_thread.RLock.acquire", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402576.961, "dur": 0.427, "name": "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402577.647, "dur": 0.184, "name": "builtins.hasattr", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402577.988, "dur": 0.392, "name": "_io.TextIOWrapper.flush", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402578.732, "dur": 0.066, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402578.582, "dur": 0.268, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402576.81, "dur": 2.149, "name": "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402558.601, "dur": 20.493, "name": "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402579.424, "dur": 0.052, "name": "_thread.RLock.release", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402579.323, "dur": 1.501, "name": "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402557.43, "dur": 23.5, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402556.686, "dur": 25.258, "name": "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402555.963, "dur": 26.129, "name": "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402531.924, "dur": 50.314, "name": "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402530.956, "dur": 52.146, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402529.355, "dur": 54.015, "name": "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077887.838, "dur": 324695.753, "name": "main (/home/edx/PycharmProjects/examples/threads/race_conditions.py:31)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402586.29, "dur": 1.552, "name": "remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:345)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402590.402, "dur": 0.213, "name": "set.discard", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402588.375, "dur": 2.283, "name": "_remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:38)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402593.018, "dur": 0.22, "name": "remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:345)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402593.583, "dur": 0.167, "name": "set.discard", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402593.389, "dur": 0.404, "name": "_remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:38)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402594.736, "dur": 0.666, "name": "remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:345)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402595.715, "dur": 0.07, "name": "set.discard", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402595.556, "dur": 0.273, "name": "_remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:38)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402597.075, "dur": 0.201, "name": "time.perf_counter", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402601.325, "dur": 2.231, "name": "builtins.print", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439077885.971, "dur": 324717.741, "name": "timeit_wrapper (/home/edx/PycharmProjects/examples/threads/utils.py:10)", "ph": "X", "cat": "FEE"}, {"pid": 7726, "tid": 7726, "ts": 10439402609.943, "dur": 0.453, "name": "log_print (/home/edx/.pyenv/versions/examples/lib/python3.8/site-packages/viztracer/tracer.py:156)", "ph": "X", "cat": "FEE"}], "viztracer_metadata": {"version": "0.15.0", "overflow": false}, "file_info": {"files": {"/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py": ["# Copyright 2001-2017 by Vinay Sajip. All Rights Reserved.\n#\n# Permission to use, copy, modify, and distribute this software and its\n# documentation for any purpose and without fee is hereby granted,\n# provided that the above copyright notice appear in all copies and that\n# both that copyright notice and this permission notice appear in\n# supporting documentation, and that the name of Vinay Sajip\n# not be used in advertising or publicity pertaining to distribution\n# of the software without specific, written prior permission.\n# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\n# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\n# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\n# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\"\"\"\nLogging package for Python. Based on PEP 282 and comments thereto in\ncomp.lang.python.\n\nCopyright (C) 2001-2017 Vinay Sajip. All Rights Reserved.\n\nTo use, simply 'import logging' and log away!\n\"\"\"\n\nimport sys, os, time, io, re, traceback, warnings, weakref, collections.abc\n\nfrom string import Template\nfrom string import Formatter as StrFormatter\n\n\n__all__ = ['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR',\n           'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO',\n           'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler',\n           'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig',\n           'captureWarnings', 'critical', 'debug', 'disable', 'error',\n           'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass',\n           'info', 'log', 'makeLogRecord', 'setLoggerClass', 'shutdown',\n           'warn', 'warning', 'getLogRecordFactory', 'setLogRecordFactory',\n           'lastResort', 'raiseExceptions']\n\nimport threading\n\n__author__  = \"Vinay Sajip <vinay_sajip@red-dove.com>\"\n__status__  = \"production\"\n# The following module attributes are no longer updated.\n__version__ = \"0.5.1.2\"\n__date__    = \"07 February 2010\"\n\n#---------------------------------------------------------------------------\n#   Miscellaneous module data\n#---------------------------------------------------------------------------\n\n#\n#_startTime is used as the base when calculating the relative time of events\n#\n_startTime = time.time()\n\n#\n#raiseExceptions is used to see if exceptions during handling should be\n#propagated\n#\nraiseExceptions = True\n\n#\n# If you don't want threading information in the log, set this to zero\n#\nlogThreads = True\n\n#\n# If you don't want multiprocessing information in the log, set this to zero\n#\nlogMultiprocessing = True\n\n#\n# If you don't want process information in the log, set this to zero\n#\nlogProcesses = True\n\n#---------------------------------------------------------------------------\n#   Level related stuff\n#---------------------------------------------------------------------------\n#\n# Default levels and level names, these can be replaced with any positive set\n# of values having corresponding names. There is a pseudo-level, NOTSET, which\n# is only really there as a lower limit for user-defined levels. Handlers and\n# loggers are initialized with NOTSET so that they will log all messages, even\n# at user-defined levels.\n#\n\nCRITICAL = 50\nFATAL = CRITICAL\nERROR = 40\nWARNING = 30\nWARN = WARNING\nINFO = 20\nDEBUG = 10\nNOTSET = 0\n\n_levelToName = {\n    CRITICAL: 'CRITICAL',\n    ERROR: 'ERROR',\n    WARNING: 'WARNING',\n    INFO: 'INFO',\n    DEBUG: 'DEBUG',\n    NOTSET: 'NOTSET',\n}\n_nameToLevel = {\n    'CRITICAL': CRITICAL,\n    'FATAL': FATAL,\n    'ERROR': ERROR,\n    'WARN': WARNING,\n    'WARNING': WARNING,\n    'INFO': INFO,\n    'DEBUG': DEBUG,\n    'NOTSET': NOTSET,\n}\n\ndef getLevelName(level):\n    \"\"\"\n    Return the textual representation of logging level 'level'.\n\n    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\n    INFO, DEBUG) then you get the corresponding string. If you have\n    associated levels with names using addLevelName then the name you have\n    associated with 'level' is returned.\n\n    If a numeric value corresponding to one of the defined levels is passed\n    in, the corresponding string representation is returned.\n\n    Otherwise, the string \"Level %s\" % level is returned.\n    \"\"\"\n    # See Issues #22386, #27937 and #29220 for why it's this way\n    result = _levelToName.get(level)\n    if result is not None:\n        return result\n    result = _nameToLevel.get(level)\n    if result is not None:\n        return result\n    return \"Level %s\" % level\n\ndef addLevelName(level, levelName):\n    \"\"\"\n    Associate 'levelName' with 'level'.\n\n    This is used when converting levels to text during message formatting.\n    \"\"\"\n    _acquireLock()\n    try:    #unlikely to cause an exception, but you never know...\n        _levelToName[level] = levelName\n        _nameToLevel[levelName] = level\n    finally:\n        _releaseLock()\n\nif hasattr(sys, '_getframe'):\n    currentframe = lambda: sys._getframe(3)\nelse: #pragma: no cover\n    def currentframe():\n        \"\"\"Return the frame object for the caller's stack frame.\"\"\"\n        try:\n            raise Exception\n        except Exception:\n            return sys.exc_info()[2].tb_frame.f_back\n\n#\n# _srcfile is used when walking the stack to check when we've got the first\n# caller stack frame, by skipping frames whose filename is that of this\n# module's source. It therefore should contain the filename of this module's\n# source file.\n#\n# Ordinarily we would use __file__ for this, but frozen modules don't always\n# have __file__ set, for some reason (see Issue #21736). Thus, we get the\n# filename from a handy code object from a function defined in this module.\n# (There's no particular reason for picking addLevelName.)\n#\n\n_srcfile = os.path.normcase(addLevelName.__code__.co_filename)\n\n# _srcfile is only used in conjunction with sys._getframe().\n# To provide compatibility with older versions of Python, set _srcfile\n# to None if _getframe() is not available; this value will prevent\n# findCaller() from being called. You can also do this if you want to avoid\n# the overhead of fetching caller information, even when _getframe() is\n# available.\n#if not hasattr(sys, '_getframe'):\n#    _srcfile = None\n\n\ndef _checkLevel(level):\n    if isinstance(level, int):\n        rv = level\n    elif str(level) == level:\n        if level not in _nameToLevel:\n            raise ValueError(\"Unknown level: %r\" % level)\n        rv = _nameToLevel[level]\n    else:\n        raise TypeError(\"Level not an integer or a valid string: %r\" % level)\n    return rv\n\n#---------------------------------------------------------------------------\n#   Thread-related stuff\n#---------------------------------------------------------------------------\n\n#\n#_lock is used to serialize access to shared data structures in this module.\n#This needs to be an RLock because fileConfig() creates and configures\n#Handlers, and so might arbitrary user threads. Since Handler code updates the\n#shared dictionary _handlers, it needs to acquire the lock. But if configuring,\n#the lock would already have been acquired - so we need an RLock.\n#The same argument applies to Loggers and Manager.loggerDict.\n#\n_lock = threading.RLock()\n\ndef _acquireLock():\n    \"\"\"\n    Acquire the module-level lock for serializing access to shared data.\n\n    This should be released with _releaseLock().\n    \"\"\"\n    if _lock:\n        _lock.acquire()\n\ndef _releaseLock():\n    \"\"\"\n    Release the module-level lock acquired by calling _acquireLock().\n    \"\"\"\n    if _lock:\n        _lock.release()\n\n\n# Prevent a held logging lock from blocking a child from logging.\n\nif not hasattr(os, 'register_at_fork'):  # Windows and friends.\n    def _register_at_fork_reinit_lock(instance):\n        pass  # no-op when os.register_at_fork does not exist.\nelse:\n    # A collection of instances with a createLock method (logging.Handler)\n    # to be called in the child after forking.  The weakref avoids us keeping\n    # discarded Handler instances alive.  A set is used to avoid accumulating\n    # duplicate registrations as createLock() is responsible for registering\n    # a new Handler instance with this set in the first place.\n    _at_fork_reinit_lock_weakset = weakref.WeakSet()\n\n    def _register_at_fork_reinit_lock(instance):\n        _acquireLock()\n        try:\n            _at_fork_reinit_lock_weakset.add(instance)\n        finally:\n            _releaseLock()\n\n    def _after_at_fork_child_reinit_locks():\n        # _acquireLock() was called in the parent before forking.\n        for handler in _at_fork_reinit_lock_weakset:\n            try:\n                handler.createLock()\n            except Exception as err:\n                # Similar to what PyErr_WriteUnraisable does.\n                print(\"Ignoring exception from logging atfork\", instance,\n                      \"._reinit_lock() method:\", err, file=sys.stderr)\n        _releaseLock()  # Acquired by os.register_at_fork(before=.\n\n\n    os.register_at_fork(before=_acquireLock,\n                        after_in_child=_after_at_fork_child_reinit_locks,\n                        after_in_parent=_releaseLock)\n\n\n#---------------------------------------------------------------------------\n#   The logging record\n#---------------------------------------------------------------------------\n\nclass LogRecord(object):\n    \"\"\"\n    A LogRecord instance represents an event being logged.\n\n    LogRecord instances are created every time something is logged. They\n    contain all the information pertinent to the event being logged. The\n    main information passed in is in msg and args, which are combined\n    using str(msg) % args to create the message field of the record. The\n    record also includes information such as when the record was created,\n    the source line where the logging call was made, and any exception\n    information to be logged.\n    \"\"\"\n    def __init__(self, name, level, pathname, lineno,\n                 msg, args, exc_info, func=None, sinfo=None, **kwargs):\n        \"\"\"\n        Initialize a logging record with interesting information.\n        \"\"\"\n        ct = time.time()\n        self.name = name\n        self.msg = msg\n        #\n        # The following statement allows passing of a dictionary as a sole\n        # argument, so that you can do something like\n        #  logging.debug(\"a %(a)d b %(b)s\", {'a':1, 'b':2})\n        # Suggested by Stefan Behnel.\n        # Note that without the test for args[0], we get a problem because\n        # during formatting, we test to see if the arg is present using\n        # 'if self.args:'. If the event being logged is e.g. 'Value is %d'\n        # and if the passed arg fails 'if self.args:' then no formatting\n        # is done. For example, logger.warning('Value is %d', 0) would log\n        # 'Value is %d' instead of 'Value is 0'.\n        # For the use case of passing a dictionary, this should not be a\n        # problem.\n        # Issue #21172: a request was made to relax the isinstance check\n        # to hasattr(args[0], '__getitem__'). However, the docs on string\n        # formatting still seem to suggest a mapping object is required.\n        # Thus, while not removing the isinstance check, it does now look\n        # for collections.abc.Mapping rather than, as before, dict.\n        if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)\n            and args[0]):\n            args = args[0]\n        self.args = args\n        self.levelname = getLevelName(level)\n        self.levelno = level\n        self.pathname = pathname\n        try:\n            self.filename = os.path.basename(pathname)\n            self.module = os.path.splitext(self.filename)[0]\n        except (TypeError, ValueError, AttributeError):\n            self.filename = pathname\n            self.module = \"Unknown module\"\n        self.exc_info = exc_info\n        self.exc_text = None      # used to cache the traceback text\n        self.stack_info = sinfo\n        self.lineno = lineno\n        self.funcName = func\n        self.created = ct\n        self.msecs = (ct - int(ct)) * 1000\n        self.relativeCreated = (self.created - _startTime) * 1000\n        if logThreads:\n            self.thread = threading.get_ident()\n            self.threadName = threading.current_thread().name\n        else: # pragma: no cover\n            self.thread = None\n            self.threadName = None\n        if not logMultiprocessing: # pragma: no cover\n            self.processName = None\n        else:\n            self.processName = 'MainProcess'\n            mp = sys.modules.get('multiprocessing')\n            if mp is not None:\n                # Errors may occur if multiprocessing has not finished loading\n                # yet - e.g. if a custom import hook causes third-party code\n                # to run when multiprocessing calls import. See issue 8200\n                # for an example\n                try:\n                    self.processName = mp.current_process().name\n                except Exception: #pragma: no cover\n                    pass\n        if logProcesses and hasattr(os, 'getpid'):\n            self.process = os.getpid()\n        else:\n            self.process = None\n\n    def __repr__(self):\n        return '<LogRecord: %s, %s, %s, %s, \"%s\">'%(self.name, self.levelno,\n            self.pathname, self.lineno, self.msg)\n\n    def getMessage(self):\n        \"\"\"\n        Return the message for this LogRecord.\n\n        Return the message for this LogRecord after merging any user-supplied\n        arguments with the message.\n        \"\"\"\n        msg = str(self.msg)\n        if self.args:\n            msg = msg % self.args\n        return msg\n\n#\n#   Determine which class to use when instantiating log records.\n#\n_logRecordFactory = LogRecord\n\ndef setLogRecordFactory(factory):\n    \"\"\"\n    Set the factory to be used when instantiating a log record.\n\n    :param factory: A callable which will be called to instantiate\n    a log record.\n    \"\"\"\n    global _logRecordFactory\n    _logRecordFactory = factory\n\ndef getLogRecordFactory():\n    \"\"\"\n    Return the factory to be used when instantiating a log record.\n    \"\"\"\n\n    return _logRecordFactory\n\ndef makeLogRecord(dict):\n    \"\"\"\n    Make a LogRecord whose attributes are defined by the specified dictionary,\n    This function is useful for converting a logging event received over\n    a socket connection (which is sent as a dictionary) into a LogRecord\n    instance.\n    \"\"\"\n    rv = _logRecordFactory(None, None, \"\", 0, \"\", (), None, None)\n    rv.__dict__.update(dict)\n    return rv\n\n\n#---------------------------------------------------------------------------\n#   Formatter classes and functions\n#---------------------------------------------------------------------------\n_str_formatter = StrFormatter()\ndel StrFormatter\n\n\nclass PercentStyle(object):\n\n    default_format = '%(message)s'\n    asctime_format = '%(asctime)s'\n    asctime_search = '%(asctime)'\n    validation_pattern = re.compile(r'%\\(\\w+\\)[#0+ -]*(\\*|\\d+)?(\\.(\\*|\\d+))?[diouxefgcrsa%]', re.I)\n\n    def __init__(self, fmt):\n        self._fmt = fmt or self.default_format\n\n    def usesTime(self):\n        return self._fmt.find(self.asctime_search) >= 0\n\n    def validate(self):\n        \"\"\"Validate the input format, ensure it matches the correct style\"\"\"\n        if not self.validation_pattern.search(self._fmt):\n            raise ValueError(\"Invalid format '%s' for '%s' style\" % (self._fmt, self.default_format[0]))\n\n    def _format(self, record):\n        return self._fmt % record.__dict__\n\n    def format(self, record):\n        try:\n            return self._format(record)\n        except KeyError as e:\n            raise ValueError('Formatting field not found in record: %s' % e)\n\n\nclass StrFormatStyle(PercentStyle):\n    default_format = '{message}'\n    asctime_format = '{asctime}'\n    asctime_search = '{asctime'\n\n    fmt_spec = re.compile(r'^(.?[<>=^])?[+ -]?#?0?(\\d+|{\\w+})?[,_]?(\\.(\\d+|{\\w+}))?[bcdefgnosx%]?$', re.I)\n    field_spec = re.compile(r'^(\\d+|\\w+)(\\.\\w+|\\[[^]]+\\])*$')\n\n    def _format(self, record):\n        return self._fmt.format(**record.__dict__)\n\n    def validate(self):\n        \"\"\"Validate the input format, ensure it is the correct string formatting style\"\"\"\n        fields = set()\n        try:\n            for _, fieldname, spec, conversion in _str_formatter.parse(self._fmt):\n                if fieldname:\n                    if not self.field_spec.match(fieldname):\n                        raise ValueError('invalid field name/expression: %r' % fieldname)\n                    fields.add(fieldname)\n                if conversion and conversion not in 'rsa':\n                    raise ValueError('invalid conversion: %r' % conversion)\n                if spec and not self.fmt_spec.match(spec):\n                    raise ValueError('bad specifier: %r' % spec)\n        except ValueError as e:\n            raise ValueError('invalid format: %s' % e)\n        if not fields:\n            raise ValueError('invalid format: no fields')\n\n\nclass StringTemplateStyle(PercentStyle):\n    default_format = '${message}'\n    asctime_format = '${asctime}'\n    asctime_search = '${asctime}'\n\n    def __init__(self, fmt):\n        self._fmt = fmt or self.default_format\n        self._tpl = Template(self._fmt)\n\n    def usesTime(self):\n        fmt = self._fmt\n        return fmt.find('$asctime') >= 0 or fmt.find(self.asctime_format) >= 0\n\n    def validate(self):\n        pattern = Template.pattern\n        fields = set()\n        for m in pattern.finditer(self._fmt):\n            d = m.groupdict()\n            if d['named']:\n                fields.add(d['named'])\n            elif d['braced']:\n                fields.add(d['braced'])\n            elif m.group(0) == '$':\n                raise ValueError('invalid format: bare \\'$\\' not allowed')\n        if not fields:\n            raise ValueError('invalid format: no fields')\n\n    def _format(self, record):\n        return self._tpl.substitute(**record.__dict__)\n\n\nBASIC_FORMAT = \"%(levelname)s:%(name)s:%(message)s\"\n\n_STYLES = {\n    '%': (PercentStyle, BASIC_FORMAT),\n    '{': (StrFormatStyle, '{levelname}:{name}:{message}'),\n    '$': (StringTemplateStyle, '${levelname}:${name}:${message}'),\n}\n\nclass Formatter(object):\n    \"\"\"\n    Formatter instances are used to convert a LogRecord to text.\n\n    Formatters need to know how a LogRecord is constructed. They are\n    responsible for converting a LogRecord to (usually) a string which can\n    be interpreted by either a human or an external system. The base Formatter\n    allows a formatting string to be specified. If none is supplied, the\n    the style-dependent default value, \"%(message)s\", \"{message}\", or\n    \"${message}\", is used.\n\n    The Formatter can be initialized with a format string which makes use of\n    knowledge of the LogRecord attributes - e.g. the default value mentioned\n    above makes use of the fact that the user's message and arguments are pre-\n    formatted into a LogRecord's message attribute. Currently, the useful\n    attributes in a LogRecord are described by:\n\n    %(name)s            Name of the logger (logging channel)\n    %(levelno)s         Numeric logging level for the message (DEBUG, INFO,\n                        WARNING, ERROR, CRITICAL)\n    %(levelname)s       Text logging level for the message (\"DEBUG\", \"INFO\",\n                        \"WARNING\", \"ERROR\", \"CRITICAL\")\n    %(pathname)s        Full pathname of the source file where the logging\n                        call was issued (if available)\n    %(filename)s        Filename portion of pathname\n    %(module)s          Module (name portion of filename)\n    %(lineno)d          Source line number where the logging call was issued\n                        (if available)\n    %(funcName)s        Function name\n    %(created)f         Time when the LogRecord was created (time.time()\n                        return value)\n    %(asctime)s         Textual time when the LogRecord was created\n    %(msecs)d           Millisecond portion of the creation time\n    %(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                        relative to the time the logging module was loaded\n                        (typically at application startup time)\n    %(thread)d          Thread ID (if available)\n    %(threadName)s      Thread name (if available)\n    %(process)d         Process ID (if available)\n    %(message)s         The result of record.getMessage(), computed just as\n                        the record is emitted\n    \"\"\"\n\n    converter = time.localtime\n\n    def __init__(self, fmt=None, datefmt=None, style='%', validate=True):\n        \"\"\"\n        Initialize the formatter with specified format strings.\n\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument. If datefmt is omitted, you get an\n        ISO8601-like (or RFC 3339-like) format.\n\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n\n        .. versionchanged:: 3.2\n           Added the ``style`` parameter.\n        \"\"\"\n        if style not in _STYLES:\n            raise ValueError('Style must be one of: %s' % ','.join(\n                             _STYLES.keys()))\n        self._style = _STYLES[style][0](fmt)\n        if validate:\n            self._style.validate()\n\n        self._fmt = self._style._fmt\n        self.datefmt = datefmt\n\n    default_time_format = '%Y-%m-%d %H:%M:%S'\n    default_msec_format = '%s,%03d'\n\n    def formatTime(self, record, datefmt=None):\n        \"\"\"\n        Return the creation time of the specified LogRecord as formatted text.\n\n        This method should be called from format() by a formatter which\n        wants to make use of a formatted time. This method can be overridden\n        in formatters to provide for any specific requirement, but the\n        basic behaviour is as follows: if datefmt (a string) is specified,\n        it is used with time.strftime() to format the creation time of the\n        record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.\n        The resulting string is returned. This function uses a user-configurable\n        function to convert the creation time to a tuple. By default,\n        time.localtime() is used; to change this for a particular formatter\n        instance, set the 'converter' attribute to a function with the same\n        signature as time.localtime() or time.gmtime(). To change it for all\n        formatters, for example if you want all logging times to be shown in GMT,\n        set the 'converter' attribute in the Formatter class.\n        \"\"\"\n        ct = self.converter(record.created)\n        if datefmt:\n            s = time.strftime(datefmt, ct)\n        else:\n            t = time.strftime(self.default_time_format, ct)\n            s = self.default_msec_format % (t, record.msecs)\n        return s\n\n    def formatException(self, ei):\n        \"\"\"\n        Format and return the specified exception information as a string.\n\n        This default implementation just uses\n        traceback.print_exception()\n        \"\"\"\n        sio = io.StringIO()\n        tb = ei[2]\n        # See issues #9427, #1553375. Commented out for now.\n        #if getattr(self, 'fullstack', False):\n        #    traceback.print_stack(tb.tb_frame.f_back, file=sio)\n        traceback.print_exception(ei[0], ei[1], tb, None, sio)\n        s = sio.getvalue()\n        sio.close()\n        if s[-1:] == \"\\n\":\n            s = s[:-1]\n        return s\n\n    def usesTime(self):\n        \"\"\"\n        Check if the format uses the creation time of the record.\n        \"\"\"\n        return self._style.usesTime()\n\n    def formatMessage(self, record):\n        return self._style.format(record)\n\n    def formatStack(self, stack_info):\n        \"\"\"\n        This method is provided as an extension point for specialized\n        formatting of stack information.\n\n        The input data is a string as returned from a call to\n        :func:`traceback.print_stack`, but with the last trailing newline\n        removed.\n\n        The base implementation just returns the value passed in.\n        \"\"\"\n        return stack_info\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record as text.\n\n        The record's attribute dictionary is used as the operand to a\n        string formatting operation which yields the returned string.\n        Before formatting the dictionary, a couple of preparatory steps\n        are carried out. The message attribute of the record is computed\n        using LogRecord.getMessage(). If the formatting string uses the\n        time (as determined by a call to usesTime(), formatTime() is\n        called to format the event time. If there is exception information,\n        it is formatted using formatException() and appended to the message.\n        \"\"\"\n        record.message = record.getMessage()\n        if self.usesTime():\n            record.asctime = self.formatTime(record, self.datefmt)\n        s = self.formatMessage(record)\n        if record.exc_info:\n            # Cache the traceback text to avoid converting it multiple times\n            # (it's constant anyway)\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + record.exc_text\n        if record.stack_info:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + self.formatStack(record.stack_info)\n        return s\n\n#\n#   The default formatter to use when no other is specified\n#\n_defaultFormatter = Formatter()\n\nclass BufferingFormatter(object):\n    \"\"\"\n    A formatter suitable for formatting a number of records.\n    \"\"\"\n    def __init__(self, linefmt=None):\n        \"\"\"\n        Optionally specify a formatter which will be used to format each\n        individual record.\n        \"\"\"\n        if linefmt:\n            self.linefmt = linefmt\n        else:\n            self.linefmt = _defaultFormatter\n\n    def formatHeader(self, records):\n        \"\"\"\n        Return the header string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def formatFooter(self, records):\n        \"\"\"\n        Return the footer string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def format(self, records):\n        \"\"\"\n        Format the specified records and return the result as a string.\n        \"\"\"\n        rv = \"\"\n        if len(records) > 0:\n            rv = rv + self.formatHeader(records)\n            for record in records:\n                rv = rv + self.linefmt.format(record)\n            rv = rv + self.formatFooter(records)\n        return rv\n\n#---------------------------------------------------------------------------\n#   Filter classes and functions\n#---------------------------------------------------------------------------\n\nclass Filter(object):\n    \"\"\"\n    Filter instances are used to perform arbitrary filtering of LogRecords.\n\n    Loggers and Handlers can optionally use Filter instances to filter\n    records as desired. The base filter class only allows events which are\n    below a certain point in the logger hierarchy. For example, a filter\n    initialized with \"A.B\" will allow events logged by loggers \"A.B\",\n    \"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\n    initialized with the empty string, all events are passed.\n    \"\"\"\n    def __init__(self, name=''):\n        \"\"\"\n        Initialize a filter.\n\n        Initialize with the name of the logger which, together with its\n        children, will have its events allowed through the filter. If no\n        name is specified, allow every event.\n        \"\"\"\n        self.name = name\n        self.nlen = len(name)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if the specified record is to be logged.\n\n        Is the specified record to be logged? Returns 0 for no, nonzero for\n        yes. If deemed appropriate, the record may be modified in-place.\n        \"\"\"\n        if self.nlen == 0:\n            return True\n        elif self.name == record.name:\n            return True\n        elif record.name.find(self.name, 0, self.nlen) != 0:\n            return False\n        return (record.name[self.nlen] == \".\")\n\nclass Filterer(object):\n    \"\"\"\n    A base class for loggers and handlers which allows them to share\n    common code.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize the list of filters to be an empty list.\n        \"\"\"\n        self.filters = []\n\n    def addFilter(self, filter):\n        \"\"\"\n        Add the specified filter to this handler.\n        \"\"\"\n        if not (filter in self.filters):\n            self.filters.append(filter)\n\n    def removeFilter(self, filter):\n        \"\"\"\n        Remove the specified filter from this handler.\n        \"\"\"\n        if filter in self.filters:\n            self.filters.remove(filter)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if a record is loggable by consulting all the filters.\n\n        The default is to allow the record to be logged; any filter can veto\n        this and the record is then dropped. Returns a zero value if a record\n        is to be dropped, else non-zero.\n\n        .. versionchanged:: 3.2\n\n           Allow filters to be just callables.\n        \"\"\"\n        rv = True\n        for f in self.filters:\n            if hasattr(f, 'filter'):\n                result = f.filter(record)\n            else:\n                result = f(record) # assume callable - will raise if not\n            if not result:\n                rv = False\n                break\n        return rv\n\n#---------------------------------------------------------------------------\n#   Handler classes and functions\n#---------------------------------------------------------------------------\n\n_handlers = weakref.WeakValueDictionary()  #map of handler names to handlers\n_handlerList = [] # added to allow handlers to be removed in reverse of order initialized\n\ndef _removeHandlerRef(wr):\n    \"\"\"\n    Remove a handler reference from the internal cleanup list.\n    \"\"\"\n    # This function can be called during module teardown, when globals are\n    # set to None. It can also be called from another thread. So we need to\n    # pre-emptively grab the necessary globals and check if they're None,\n    # to prevent race conditions and failures during interpreter shutdown.\n    acquire, release, handlers = _acquireLock, _releaseLock, _handlerList\n    if acquire and release and handlers:\n        acquire()\n        try:\n            if wr in handlers:\n                handlers.remove(wr)\n        finally:\n            release()\n\ndef _addHandlerRef(handler):\n    \"\"\"\n    Add a handler to the internal cleanup list using a weak reference.\n    \"\"\"\n    _acquireLock()\n    try:\n        _handlerList.append(weakref.ref(handler, _removeHandlerRef))\n    finally:\n        _releaseLock()\n\nclass Handler(Filterer):\n    \"\"\"\n    Handler instances dispatch logging events to specific destinations.\n\n    The base handler class. Acts as a placeholder which defines the Handler\n    interface. Handlers can optionally use Formatter instances to format\n    records as desired. By default, no formatter is specified; in this case,\n    the 'raw' message as determined by record.message is logged.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initializes the instance - basically setting the formatter to None\n        and the filter list to empty.\n        \"\"\"\n        Filterer.__init__(self)\n        self._name = None\n        self.level = _checkLevel(level)\n        self.formatter = None\n        # Add the handler to the global _handlerList (for cleanup on shutdown)\n        _addHandlerRef(self)\n        self.createLock()\n\n    def get_name(self):\n        return self._name\n\n    def set_name(self, name):\n        _acquireLock()\n        try:\n            if self._name in _handlers:\n                del _handlers[self._name]\n            self._name = name\n            if name:\n                _handlers[name] = self\n        finally:\n            _releaseLock()\n\n    name = property(get_name, set_name)\n\n    def createLock(self):\n        \"\"\"\n        Acquire a thread lock for serializing access to the underlying I/O.\n        \"\"\"\n        self.lock = threading.RLock()\n        _register_at_fork_reinit_lock(self)\n\n    def acquire(self):\n        \"\"\"\n        Acquire the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.acquire()\n\n    def release(self):\n        \"\"\"\n        Release the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.release()\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this handler.  level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record.\n\n        If a formatter is set, use it. Otherwise, use the default formatter\n        for the module.\n        \"\"\"\n        if self.formatter:\n            fmt = self.formatter\n        else:\n            fmt = _defaultFormatter\n        return fmt.format(record)\n\n    def emit(self, record):\n        \"\"\"\n        Do whatever it takes to actually log the specified logging record.\n\n        This version is intended to be implemented by subclasses and so\n        raises a NotImplementedError.\n        \"\"\"\n        raise NotImplementedError('emit must be implemented '\n                                  'by Handler subclasses')\n\n    def handle(self, record):\n        \"\"\"\n        Conditionally emit the specified logging record.\n\n        Emission depends on filters which may have been added to the handler.\n        Wrap the actual emission of the record with acquisition/release of\n        the I/O thread lock. Returns whether the filter passed the record for\n        emission.\n        \"\"\"\n        rv = self.filter(record)\n        if rv:\n            self.acquire()\n            try:\n                self.emit(record)\n            finally:\n                self.release()\n        return rv\n\n    def setFormatter(self, fmt):\n        \"\"\"\n        Set the formatter for this handler.\n        \"\"\"\n        self.formatter = fmt\n\n    def flush(self):\n        \"\"\"\n        Ensure all logging output has been flushed.\n\n        This version does nothing and is intended to be implemented by\n        subclasses.\n        \"\"\"\n        pass\n\n    def close(self):\n        \"\"\"\n        Tidy up any resources used by the handler.\n\n        This version removes the handler from an internal map of handlers,\n        _handlers, which is used for handler lookup by name. Subclasses\n        should ensure that this gets called from overridden close()\n        methods.\n        \"\"\"\n        #get the module data lock, as we're updating a shared structure.\n        _acquireLock()\n        try:    #unlikely to raise an exception, but you never know...\n            if self._name and self._name in _handlers:\n                del _handlers[self._name]\n        finally:\n            _releaseLock()\n\n    def handleError(self, record):\n        \"\"\"\n        Handle errors which occur during an emit() call.\n\n        This method should be called from handlers when an exception is\n        encountered during an emit() call. If raiseExceptions is false,\n        exceptions get silently ignored. This is what is mostly wanted\n        for a logging system - most users will not care about errors in\n        the logging system, they are more interested in application errors.\n        You could, however, replace this with a custom handler if you wish.\n        The record which was being processed is passed in to this method.\n        \"\"\"\n        if raiseExceptions and sys.stderr:  # see issue 13807\n            t, v, tb = sys.exc_info()\n            try:\n                sys.stderr.write('--- Logging error ---\\n')\n                traceback.print_exception(t, v, tb, None, sys.stderr)\n                sys.stderr.write('Call stack:\\n')\n                # Walk the stack frame up until we're out of logging,\n                # so as to print the calling context.\n                frame = tb.tb_frame\n                while (frame and os.path.dirname(frame.f_code.co_filename) ==\n                       __path__[0]):\n                    frame = frame.f_back\n                if frame:\n                    traceback.print_stack(frame, file=sys.stderr)\n                else:\n                    # couldn't find the right stack frame, for some reason\n                    sys.stderr.write('Logged from file %s, line %s\\n' % (\n                                     record.filename, record.lineno))\n                # Issue 18671: output logging message and arguments\n                try:\n                    sys.stderr.write('Message: %r\\n'\n                                     'Arguments: %s\\n' % (record.msg,\n                                                          record.args))\n                except RecursionError:  # See issue 36272\n                    raise\n                except Exception:\n                    sys.stderr.write('Unable to print the message and arguments'\n                                     ' - possible formatting error.\\nUse the'\n                                     ' traceback above to help find the error.\\n'\n                                    )\n            except OSError: #pragma: no cover\n                pass    # see issue 5971\n            finally:\n                del t, v, tb\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        return '<%s (%s)>' % (self.__class__.__name__, level)\n\nclass StreamHandler(Handler):\n    \"\"\"\n    A handler class which writes logging records, appropriately formatted,\n    to a stream. Note that this class does not close the stream, as\n    sys.stdout or sys.stderr may be used.\n    \"\"\"\n\n    terminator = '\\n'\n\n    def __init__(self, stream=None):\n        \"\"\"\n        Initialize the handler.\n\n        If stream is not specified, sys.stderr is used.\n        \"\"\"\n        Handler.__init__(self)\n        if stream is None:\n            stream = sys.stderr\n        self.stream = stream\n\n    def flush(self):\n        \"\"\"\n        Flushes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            if self.stream and hasattr(self.stream, \"flush\"):\n                self.stream.flush()\n        finally:\n            self.release()\n\n    def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If a formatter is specified, it is used to format the record.\n        The record is then written to the stream with a trailing newline.  If\n        exception information is present, it is formatted using\n        traceback.print_exception and appended to the stream.  If the stream\n        has an 'encoding' attribute, it is used to determine how to do the\n        output to the stream.\n        \"\"\"\n        try:\n            msg = self.format(record)\n            stream = self.stream\n            # issue 35046: merged two stream.writes into one.\n            stream.write(msg + self.terminator)\n            self.flush()\n        except RecursionError:  # See issue 36272\n            raise\n        except Exception:\n            self.handleError(record)\n\n    def setStream(self, stream):\n        \"\"\"\n        Sets the StreamHandler's stream to the specified value,\n        if it is different.\n\n        Returns the old stream, if the stream was changed, or None\n        if it wasn't.\n        \"\"\"\n        if stream is self.stream:\n            result = None\n        else:\n            result = self.stream\n            self.acquire()\n            try:\n                self.flush()\n                self.stream = stream\n            finally:\n                self.release()\n        return result\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        name = getattr(self.stream, 'name', '')\n        #  bpo-36015: name can be an int\n        name = str(name)\n        if name:\n            name += ' '\n        return '<%s %s(%s)>' % (self.__class__.__name__, name, level)\n\n\nclass FileHandler(StreamHandler):\n    \"\"\"\n    A handler class which writes formatted logging records to disk files.\n    \"\"\"\n    def __init__(self, filename, mode='a', encoding=None, delay=False):\n        \"\"\"\n        Open the specified file and use it as the stream for logging.\n        \"\"\"\n        # Issue #27493: add support for Path objects to be passed in\n        filename = os.fspath(filename)\n        #keep the absolute path, otherwise derived classes which use this\n        #may come a cropper when the current directory changes\n        self.baseFilename = os.path.abspath(filename)\n        self.mode = mode\n        self.encoding = encoding\n        self.delay = delay\n        if delay:\n            #We don't open the stream, but we still need to call the\n            #Handler constructor to set level, formatter, lock etc.\n            Handler.__init__(self)\n            self.stream = None\n        else:\n            StreamHandler.__init__(self, self._open())\n\n    def close(self):\n        \"\"\"\n        Closes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            try:\n                if self.stream:\n                    try:\n                        self.flush()\n                    finally:\n                        stream = self.stream\n                        self.stream = None\n                        if hasattr(stream, \"close\"):\n                            stream.close()\n            finally:\n                # Issue #19523: call unconditionally to\n                # prevent a handler leak when delay is set\n                StreamHandler.close(self)\n        finally:\n            self.release()\n\n    def _open(self):\n        \"\"\"\n        Open the current base file with the (original) mode and encoding.\n        Return the resulting stream.\n        \"\"\"\n        return open(self.baseFilename, self.mode, encoding=self.encoding)\n\n    def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If the stream was not opened because 'delay' was specified in the\n        constructor, open it before calling the superclass's emit.\n        \"\"\"\n        if self.stream is None:\n            self.stream = self._open()\n        StreamHandler.emit(self, record)\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        return '<%s %s (%s)>' % (self.__class__.__name__, self.baseFilename, level)\n\n\nclass _StderrHandler(StreamHandler):\n    \"\"\"\n    This class is like a StreamHandler using sys.stderr, but always uses\n    whatever sys.stderr is currently set to rather than the value of\n    sys.stderr at handler construction time.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initialize the handler.\n        \"\"\"\n        Handler.__init__(self, level)\n\n    @property\n    def stream(self):\n        return sys.stderr\n\n\n_defaultLastResort = _StderrHandler(WARNING)\nlastResort = _defaultLastResort\n\n#---------------------------------------------------------------------------\n#   Manager classes and functions\n#---------------------------------------------------------------------------\n\nclass PlaceHolder(object):\n    \"\"\"\n    PlaceHolder instances are used in the Manager logger hierarchy to take\n    the place of nodes for which no loggers have been defined. This class is\n    intended for internal use only and not as part of the public API.\n    \"\"\"\n    def __init__(self, alogger):\n        \"\"\"\n        Initialize with the specified logger being a child of this placeholder.\n        \"\"\"\n        self.loggerMap = { alogger : None }\n\n    def append(self, alogger):\n        \"\"\"\n        Add the specified logger as a child of this placeholder.\n        \"\"\"\n        if alogger not in self.loggerMap:\n            self.loggerMap[alogger] = None\n\n#\n#   Determine which class to use when instantiating loggers.\n#\n\ndef setLoggerClass(klass):\n    \"\"\"\n    Set the class to be used when instantiating a logger. The class should\n    define __init__() such that only a name argument is required, and the\n    __init__() should call Logger.__init__()\n    \"\"\"\n    if klass != Logger:\n        if not issubclass(klass, Logger):\n            raise TypeError(\"logger not derived from logging.Logger: \"\n                            + klass.__name__)\n    global _loggerClass\n    _loggerClass = klass\n\ndef getLoggerClass():\n    \"\"\"\n    Return the class to be used when instantiating a logger.\n    \"\"\"\n    return _loggerClass\n\nclass Manager(object):\n    \"\"\"\n    There is [under normal circumstances] just one Manager instance, which\n    holds the hierarchy of loggers.\n    \"\"\"\n    def __init__(self, rootnode):\n        \"\"\"\n        Initialize the manager with the root node of the logger hierarchy.\n        \"\"\"\n        self.root = rootnode\n        self.disable = 0\n        self.emittedNoHandlerWarning = False\n        self.loggerDict = {}\n        self.loggerClass = None\n        self.logRecordFactory = None\n\n    def getLogger(self, name):\n        \"\"\"\n        Get a logger with the specified name (channel name), creating it\n        if it doesn't yet exist. This name is a dot-separated hierarchical\n        name, such as \"a\", \"a.b\", \"a.b.c\" or similar.\n\n        If a PlaceHolder existed for the specified name [i.e. the logger\n        didn't exist but a child of it did], replace it with the created\n        logger and fix up the parent/child references which pointed to the\n        placeholder to now point to the logger.\n        \"\"\"\n        rv = None\n        if not isinstance(name, str):\n            raise TypeError('A logger name must be a string')\n        _acquireLock()\n        try:\n            if name in self.loggerDict:\n                rv = self.loggerDict[name]\n                if isinstance(rv, PlaceHolder):\n                    ph = rv\n                    rv = (self.loggerClass or _loggerClass)(name)\n                    rv.manager = self\n                    self.loggerDict[name] = rv\n                    self._fixupChildren(ph, rv)\n                    self._fixupParents(rv)\n            else:\n                rv = (self.loggerClass or _loggerClass)(name)\n                rv.manager = self\n                self.loggerDict[name] = rv\n                self._fixupParents(rv)\n        finally:\n            _releaseLock()\n        return rv\n\n    def setLoggerClass(self, klass):\n        \"\"\"\n        Set the class to be used when instantiating a logger with this Manager.\n        \"\"\"\n        if klass != Logger:\n            if not issubclass(klass, Logger):\n                raise TypeError(\"logger not derived from logging.Logger: \"\n                                + klass.__name__)\n        self.loggerClass = klass\n\n    def setLogRecordFactory(self, factory):\n        \"\"\"\n        Set the factory to be used when instantiating a log record with this\n        Manager.\n        \"\"\"\n        self.logRecordFactory = factory\n\n    def _fixupParents(self, alogger):\n        \"\"\"\n        Ensure that there are either loggers or placeholders all the way\n        from the specified logger to the root of the logger hierarchy.\n        \"\"\"\n        name = alogger.name\n        i = name.rfind(\".\")\n        rv = None\n        while (i > 0) and not rv:\n            substr = name[:i]\n            if substr not in self.loggerDict:\n                self.loggerDict[substr] = PlaceHolder(alogger)\n            else:\n                obj = self.loggerDict[substr]\n                if isinstance(obj, Logger):\n                    rv = obj\n                else:\n                    assert isinstance(obj, PlaceHolder)\n                    obj.append(alogger)\n            i = name.rfind(\".\", 0, i - 1)\n        if not rv:\n            rv = self.root\n        alogger.parent = rv\n\n    def _fixupChildren(self, ph, alogger):\n        \"\"\"\n        Ensure that children of the placeholder ph are connected to the\n        specified logger.\n        \"\"\"\n        name = alogger.name\n        namelen = len(name)\n        for c in ph.loggerMap.keys():\n            #The if means ... if not c.parent.name.startswith(nm)\n            if c.parent.name[:namelen] != name:\n                alogger.parent = c.parent\n                c.parent = alogger\n\n    def _clear_cache(self):\n        \"\"\"\n        Clear the cache for all loggers in loggerDict\n        Called when level changes are made\n        \"\"\"\n\n        _acquireLock()\n        for logger in self.loggerDict.values():\n            if isinstance(logger, Logger):\n                logger._cache.clear()\n        self.root._cache.clear()\n        _releaseLock()\n\n#---------------------------------------------------------------------------\n#   Logger classes and functions\n#---------------------------------------------------------------------------\n\nclass Logger(Filterer):\n    \"\"\"\n    Instances of the Logger class represent a single logging channel. A\n    \"logging channel\" indicates an area of an application. Exactly how an\n    \"area\" is defined is up to the application developer. Since an\n    application can have any number of areas, logging channels are identified\n    by a unique string. Application areas can be nested (e.g. an area\n    of \"input processing\" might include sub-areas \"read CSV files\", \"read\n    XLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\n    channel names are organized into a namespace hierarchy where levels are\n    separated by periods, much like the Java or Python package namespace. So\n    in the instance given above, channel names might be \"input\" for the upper\n    level, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\n    There is no arbitrary limit to the depth of nesting.\n    \"\"\"\n    def __init__(self, name, level=NOTSET):\n        \"\"\"\n        Initialize the logger with a name and an optional level.\n        \"\"\"\n        Filterer.__init__(self)\n        self.name = name\n        self.level = _checkLevel(level)\n        self.parent = None\n        self.propagate = True\n        self.handlers = []\n        self.disabled = False\n        self._cache = {}\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this logger.  level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n        self.manager._clear_cache()\n\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'DEBUG'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(DEBUG):\n            self._log(DEBUG, msg, args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'INFO'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(INFO):\n            self._log(INFO, msg, args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'WARNING'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(WARNING):\n            self._log(WARNING, msg, args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn(\"The 'warn' method is deprecated, \"\n            \"use 'warning' instead\", DeprecationWarning, 2)\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'ERROR'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(ERROR):\n            self._log(ERROR, msg, args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Convenience method for logging an ERROR with exception information.\n        \"\"\"\n        self.error(msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'CRITICAL'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.critical(\"Houston, we have a %s\", \"major disaster\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(CRITICAL):\n            self._log(CRITICAL, msg, args, **kwargs)\n\n    fatal = critical\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with the integer severity 'level'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=1)\n        \"\"\"\n        if not isinstance(level, int):\n            if raiseExceptions:\n                raise TypeError(\"level must be an integer\")\n            else:\n                return\n        if self.isEnabledFor(level):\n            self._log(level, msg, args, **kwargs)\n\n    def findCaller(self, stack_info=False, stacklevel=1):\n        \"\"\"\n        Find the stack frame of the caller so that we can note the source\n        file name, line number and function name.\n        \"\"\"\n        f = currentframe()\n        #On some versions of IronPython, currentframe() returns None if\n        #IronPython isn't run with -X:Frames.\n        if f is not None:\n            f = f.f_back\n        orig_f = f\n        while f and stacklevel > 1:\n            f = f.f_back\n            stacklevel -= 1\n        if not f:\n            f = orig_f\n        rv = \"(unknown file)\", 0, \"(unknown function)\", None\n        while hasattr(f, \"f_code\"):\n            co = f.f_code\n            filename = os.path.normcase(co.co_filename)\n            if filename == _srcfile:\n                f = f.f_back\n                continue\n            sinfo = None\n            if stack_info:\n                sio = io.StringIO()\n                sio.write('Stack (most recent call last):\\n')\n                traceback.print_stack(f, file=sio)\n                sinfo = sio.getvalue()\n                if sinfo[-1] == '\\n':\n                    sinfo = sinfo[:-1]\n                sio.close()\n            rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)\n            break\n        return rv\n\n    def makeRecord(self, name, level, fn, lno, msg, args, exc_info,\n                   func=None, extra=None, sinfo=None):\n        \"\"\"\n        A factory method which can be overridden in subclasses to create\n        specialized LogRecords.\n        \"\"\"\n        rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,\n                             sinfo)\n        if extra is not None:\n            for key in extra:\n                if (key in [\"message\", \"asctime\"]) or (key in rv.__dict__):\n                    raise KeyError(\"Attempt to overwrite %r in LogRecord\" % key)\n                rv.__dict__[key] = extra[key]\n        return rv\n\n    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False,\n             stacklevel=1):\n        \"\"\"\n        Low-level logging routine which creates a LogRecord and then calls\n        all the handlers of this logger to handle the record.\n        \"\"\"\n        sinfo = None\n        if _srcfile:\n            #IronPython doesn't track Python frames, so findCaller raises an\n            #exception on some versions of IronPython. We trap it here so that\n            #IronPython can use logging.\n            try:\n                fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)\n            except ValueError: # pragma: no cover\n                fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        else: # pragma: no cover\n            fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        if exc_info:\n            if isinstance(exc_info, BaseException):\n                exc_info = (type(exc_info), exc_info, exc_info.__traceback__)\n            elif not isinstance(exc_info, tuple):\n                exc_info = sys.exc_info()\n        record = self.makeRecord(self.name, level, fn, lno, msg, args,\n                                 exc_info, func, extra, sinfo)\n        self.handle(record)\n\n    def handle(self, record):\n        \"\"\"\n        Call the handlers for the specified record.\n\n        This method is used for unpickled records received from a socket, as\n        well as those created locally. Logger-level filtering is applied.\n        \"\"\"\n        if (not self.disabled) and self.filter(record):\n            self.callHandlers(record)\n\n    def addHandler(self, hdlr):\n        \"\"\"\n        Add the specified handler to this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if not (hdlr in self.handlers):\n                self.handlers.append(hdlr)\n        finally:\n            _releaseLock()\n\n    def removeHandler(self, hdlr):\n        \"\"\"\n        Remove the specified handler from this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if hdlr in self.handlers:\n                self.handlers.remove(hdlr)\n        finally:\n            _releaseLock()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if this logger has any handlers configured.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. Return True if a handler was found, else False.\n        Stop searching up the hierarchy whenever a logger with the \"propagate\"\n        attribute set to zero is found - that will be the last logger which\n        is checked for the existence of handlers.\n        \"\"\"\n        c = self\n        rv = False\n        while c:\n            if c.handlers:\n                rv = True\n                break\n            if not c.propagate:\n                break\n            else:\n                c = c.parent\n        return rv\n\n    def callHandlers(self, record):\n        \"\"\"\n        Pass a record to all relevant handlers.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. If no handler was found, output a one-off error\n        message to sys.stderr. Stop searching up the hierarchy whenever a\n        logger with the \"propagate\" attribute set to zero is found - that\n        will be the last logger whose handlers are called.\n        \"\"\"\n        c = self\n        found = 0\n        while c:\n            for hdlr in c.handlers:\n                found = found + 1\n                if record.levelno >= hdlr.level:\n                    hdlr.handle(record)\n            if not c.propagate:\n                c = None    #break out\n            else:\n                c = c.parent\n        if (found == 0):\n            if lastResort:\n                if record.levelno >= lastResort.level:\n                    lastResort.handle(record)\n            elif raiseExceptions and not self.manager.emittedNoHandlerWarning:\n                sys.stderr.write(\"No handlers could be found for logger\"\n                                 \" \\\"%s\\\"\\n\" % self.name)\n                self.manager.emittedNoHandlerWarning = True\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for this logger.\n\n        Loop through this logger and its parents in the logger hierarchy,\n        looking for a non-zero logging level. Return the first one found.\n        \"\"\"\n        logger = self\n        while logger:\n            if logger.level:\n                return logger.level\n            logger = logger.parent\n        return NOTSET\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        if self.disabled:\n            return False\n\n        try:\n            return self._cache[level]\n        except KeyError:\n            _acquireLock()\n            if self.manager.disable >= level:\n                is_enabled = self._cache[level] = False\n            else:\n                is_enabled = self._cache[level] = level >= self.getEffectiveLevel()\n            _releaseLock()\n\n            return is_enabled\n\n    def getChild(self, suffix):\n        \"\"\"\n        Get a logger which is a descendant to this one.\n\n        This is a convenience method, such that\n\n        logging.getLogger('abc').getChild('def.ghi')\n\n        is the same as\n\n        logging.getLogger('abc.def.ghi')\n\n        It's useful, for example, when the parent logger is named using\n        __name__ rather than a literal string.\n        \"\"\"\n        if self.root is not self:\n            suffix = '.'.join((self.name, suffix))\n        return self.manager.getLogger(suffix)\n\n    def __repr__(self):\n        level = getLevelName(self.getEffectiveLevel())\n        return '<%s %s (%s)>' % (self.__class__.__name__, self.name, level)\n\n    def __reduce__(self):\n        # In general, only the root logger will not be accessible via its name.\n        # However, the root logger's class has its own __reduce__ method.\n        if getLogger(self.name) is not self:\n            import pickle\n            raise pickle.PicklingError('logger cannot be pickled')\n        return getLogger, (self.name,)\n\n\nclass RootLogger(Logger):\n    \"\"\"\n    A root logger is not that different to any other logger, except that\n    it must have a logging level and there is only one instance of it in\n    the hierarchy.\n    \"\"\"\n    def __init__(self, level):\n        \"\"\"\n        Initialize the logger with the name \"root\".\n        \"\"\"\n        Logger.__init__(self, \"root\", level)\n\n    def __reduce__(self):\n        return getLogger, ()\n\n_loggerClass = Logger\n\nclass LoggerAdapter(object):\n    \"\"\"\n    An adapter for loggers which makes it easier to specify contextual\n    information in logging output.\n    \"\"\"\n\n    def __init__(self, logger, extra):\n        \"\"\"\n        Initialize the adapter with a logger and a dict-like object which\n        provides contextual information. This constructor signature allows\n        easy stacking of LoggerAdapters, if so desired.\n\n        You can effectively pass keyword arguments as shown in the\n        following example:\n\n        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2=\"v2\"))\n        \"\"\"\n        self.logger = logger\n        self.extra = extra\n\n    def process(self, msg, kwargs):\n        \"\"\"\n        Process the logging message and keyword arguments passed in to\n        a logging call to insert contextual information. You can either\n        manipulate the message itself, the keyword args or both. Return\n        the message and kwargs modified (or not) to suit your needs.\n\n        Normally, you'll only need to override this one method in a\n        LoggerAdapter subclass for your specific needs.\n        \"\"\"\n        kwargs[\"extra\"] = self.extra\n        return msg, kwargs\n\n    #\n    # Boilerplate convenience methods\n    #\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a debug call to the underlying logger.\n        \"\"\"\n        self.log(DEBUG, msg, *args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an info call to the underlying logger.\n        \"\"\"\n        self.log(INFO, msg, *args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a warning call to the underlying logger.\n        \"\"\"\n        self.log(WARNING, msg, *args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn(\"The 'warn' method is deprecated, \"\n            \"use 'warning' instead\", DeprecationWarning, 2)\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an error call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Delegate an exception call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a critical call to the underlying logger.\n        \"\"\"\n        self.log(CRITICAL, msg, *args, **kwargs)\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a log call to the underlying logger, after adding\n        contextual information from this adapter instance.\n        \"\"\"\n        if self.isEnabledFor(level):\n            msg, kwargs = self.process(msg, kwargs)\n            self.logger.log(level, msg, *args, **kwargs)\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        return self.logger.isEnabledFor(level)\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the specified level on the underlying logger.\n        \"\"\"\n        self.logger.setLevel(level)\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for the underlying logger.\n        \"\"\"\n        return self.logger.getEffectiveLevel()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if the underlying logger has any handlers.\n        \"\"\"\n        return self.logger.hasHandlers()\n\n    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):\n        \"\"\"\n        Low-level log implementation, proxied to allow nested logger adapters.\n        \"\"\"\n        return self.logger._log(\n            level,\n            msg,\n            args,\n            exc_info=exc_info,\n            extra=extra,\n            stack_info=stack_info,\n        )\n\n    @property\n    def manager(self):\n        return self.logger.manager\n\n    @manager.setter\n    def manager(self, value):\n        self.logger.manager = value\n\n    @property\n    def name(self):\n        return self.logger.name\n\n    def __repr__(self):\n        logger = self.logger\n        level = getLevelName(logger.getEffectiveLevel())\n        return '<%s %s (%s)>' % (self.__class__.__name__, logger.name, level)\n\nroot = RootLogger(WARNING)\nLogger.root = root\nLogger.manager = Manager(Logger.root)\n\n#---------------------------------------------------------------------------\n# Configuration classes and functions\n#---------------------------------------------------------------------------\n\ndef basicConfig(**kwargs):\n    \"\"\"\n    Do basic configuration for the logging system.\n\n    This function does nothing if the root logger already has handlers\n    configured, unless the keyword argument *force* is set to ``True``.\n    It is a convenience method intended for use by simple scripts\n    to do one-shot configuration of the logging package.\n\n    The default behaviour is to create a StreamHandler which writes to\n    sys.stderr, set a formatter using the BASIC_FORMAT format string, and\n    add the handler to the root logger.\n\n    A number of optional keyword arguments may be specified, which can alter\n    the default behaviour.\n\n    filename  Specifies that a FileHandler be created, using the specified\n              filename, rather than a StreamHandler.\n    filemode  Specifies the mode to open the file, if filename is specified\n              (if filemode is unspecified, it defaults to 'a').\n    format    Use the specified format string for the handler.\n    datefmt   Use the specified date/time format.\n    style     If a format string is specified, use this to specify the\n              type of format string (possible values '%', '{', '$', for\n              %-formatting, :meth:`str.format` and :class:`string.Template`\n              - defaults to '%').\n    level     Set the root logger level to the specified level.\n    stream    Use the specified stream to initialize the StreamHandler. Note\n              that this argument is incompatible with 'filename' - if both\n              are present, 'stream' is ignored.\n    handlers  If specified, this should be an iterable of already created\n              handlers, which will be added to the root handler. Any handler\n              in the list which does not have a formatter assigned will be\n              assigned the formatter created in this function.\n    force     If this keyword  is specified as true, any existing handlers\n              attached to the root logger are removed and closed, before\n              carrying out the configuration as specified by the other\n              arguments.\n    Note that you could specify a stream created using open(filename, mode)\n    rather than passing the filename and mode in. However, it should be\n    remembered that StreamHandler does not close its stream (since it may be\n    using sys.stdout or sys.stderr), whereas FileHandler closes its stream\n    when the handler is closed.\n\n    .. versionchanged:: 3.8\n       Added the ``force`` parameter.\n\n    .. versionchanged:: 3.2\n       Added the ``style`` parameter.\n\n    .. versionchanged:: 3.3\n       Added the ``handlers`` parameter. A ``ValueError`` is now thrown for\n       incompatible arguments (e.g. ``handlers`` specified together with\n       ``filename``/``filemode``, or ``filename``/``filemode`` specified\n       together with ``stream``, or ``handlers`` specified together with\n       ``stream``.\n    \"\"\"\n    # Add thread safety in case someone mistakenly calls\n    # basicConfig() from multiple threads\n    _acquireLock()\n    try:\n        force = kwargs.pop('force', False)\n        if force:\n            for h in root.handlers[:]:\n                root.removeHandler(h)\n                h.close()\n        if len(root.handlers) == 0:\n            handlers = kwargs.pop(\"handlers\", None)\n            if handlers is None:\n                if \"stream\" in kwargs and \"filename\" in kwargs:\n                    raise ValueError(\"'stream' and 'filename' should not be \"\n                                     \"specified together\")\n            else:\n                if \"stream\" in kwargs or \"filename\" in kwargs:\n                    raise ValueError(\"'stream' or 'filename' should not be \"\n                                     \"specified together with 'handlers'\")\n            if handlers is None:\n                filename = kwargs.pop(\"filename\", None)\n                mode = kwargs.pop(\"filemode\", 'a')\n                if filename:\n                    h = FileHandler(filename, mode)\n                else:\n                    stream = kwargs.pop(\"stream\", None)\n                    h = StreamHandler(stream)\n                handlers = [h]\n            dfs = kwargs.pop(\"datefmt\", None)\n            style = kwargs.pop(\"style\", '%')\n            if style not in _STYLES:\n                raise ValueError('Style must be one of: %s' % ','.join(\n                                 _STYLES.keys()))\n            fs = kwargs.pop(\"format\", _STYLES[style][1])\n            fmt = Formatter(fs, dfs, style)\n            for h in handlers:\n                if h.formatter is None:\n                    h.setFormatter(fmt)\n                root.addHandler(h)\n            level = kwargs.pop(\"level\", None)\n            if level is not None:\n                root.setLevel(level)\n            if kwargs:\n                keys = ', '.join(kwargs.keys())\n                raise ValueError('Unrecognised argument(s): %s' % keys)\n    finally:\n        _releaseLock()\n\n#---------------------------------------------------------------------------\n# Utility functions at module level.\n# Basically delegate everything to the root logger.\n#---------------------------------------------------------------------------\n\ndef getLogger(name=None):\n    \"\"\"\n    Return a logger with the specified name, creating it if necessary.\n\n    If no name is specified, return the root logger.\n    \"\"\"\n    if name:\n        return Logger.manager.getLogger(name)\n    else:\n        return root\n\ndef critical(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'CRITICAL' on the root logger. If the logger\n    has no handlers, call basicConfig() to add a console handler with a\n    pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.critical(msg, *args, **kwargs)\n\nfatal = critical\n\ndef error(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.error(msg, *args, **kwargs)\n\ndef exception(msg, *args, exc_info=True, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger, with exception\n    information. If the logger has no handlers, basicConfig() is called to add\n    a console handler with a pre-defined format.\n    \"\"\"\n    error(msg, *args, exc_info=exc_info, **kwargs)\n\ndef warning(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'WARNING' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.warning(msg, *args, **kwargs)\n\ndef warn(msg, *args, **kwargs):\n    warnings.warn(\"The 'warn' function is deprecated, \"\n        \"use 'warning' instead\", DeprecationWarning, 2)\n    warning(msg, *args, **kwargs)\n\ndef info(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'INFO' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.info(msg, *args, **kwargs)\n\ndef debug(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'DEBUG' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.debug(msg, *args, **kwargs)\n\ndef log(level, msg, *args, **kwargs):\n    \"\"\"\n    Log 'msg % args' with the integer severity 'level' on the root logger. If\n    the logger has no handlers, call basicConfig() to add a console handler\n    with a pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.log(level, msg, *args, **kwargs)\n\ndef disable(level=CRITICAL):\n    \"\"\"\n    Disable all logging calls of severity 'level' and below.\n    \"\"\"\n    root.manager.disable = level\n    root.manager._clear_cache()\n\ndef shutdown(handlerList=_handlerList):\n    \"\"\"\n    Perform any cleanup actions in the logging system (e.g. flushing\n    buffers).\n\n    Should be called at application exit.\n    \"\"\"\n    for wr in reversed(handlerList[:]):\n        #errors might occur, for example, if files are locked\n        #we just ignore them if raiseExceptions is not set\n        try:\n            h = wr()\n            if h:\n                try:\n                    h.acquire()\n                    h.flush()\n                    h.close()\n                except (OSError, ValueError):\n                    # Ignore errors which might be caused\n                    # because handlers have been closed but\n                    # references to them are still around at\n                    # application exit.\n                    pass\n                finally:\n                    h.release()\n        except: # ignore everything, as we're shutting down\n            if raiseExceptions:\n                raise\n            #else, swallow\n\n#Let's try and shutdown automatically on application exit...\nimport atexit\natexit.register(shutdown)\n\n# Null handler\n\nclass NullHandler(Handler):\n    \"\"\"\n    This handler does nothing. It's intended to be used to avoid the\n    \"No handlers could be found for logger XXX\" one-off warning. This is\n    important for library code, which may contain code to log events. If a user\n    of the library does not configure logging, the one-off warning might be\n    produced; to avoid this, the library developer simply needs to instantiate\n    a NullHandler and add it to the top-level logger of the library module or\n    package.\n    \"\"\"\n    def handle(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def emit(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def createLock(self):\n        self.lock = None\n\n# Warnings integration\n\n_warnings_showwarning = None\n\ndef _showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"\n    Implementation of showwarnings which redirects to logging, which will first\n    check to see if the file parameter is None. If a file is specified, it will\n    delegate to the original warnings implementation of showwarning. Otherwise,\n    it will call warnings.formatwarning and will log the resulting string to a\n    warnings logger named \"py.warnings\" with level logging.WARNING.\n    \"\"\"\n    if file is not None:\n        if _warnings_showwarning is not None:\n            _warnings_showwarning(message, category, filename, lineno, file, line)\n    else:\n        s = warnings.formatwarning(message, category, filename, lineno, line)\n        logger = getLogger(\"py.warnings\")\n        if not logger.handlers:\n            logger.addHandler(NullHandler())\n        logger.warning(\"%s\", s)\n\ndef captureWarnings(capture):\n    \"\"\"\n    If capture is true, redirect all warnings to the logging package.\n    If capture is False, ensure that warnings are not redirected to logging\n    but to their original destinations.\n    \"\"\"\n    global _warnings_showwarning\n    if capture:\n        if _warnings_showwarning is None:\n            _warnings_showwarning = warnings.showwarning\n            warnings.showwarning = _showwarning\n    else:\n        if _warnings_showwarning is not None:\n            warnings.showwarning = _warnings_showwarning\n            _warnings_showwarning = None\n", 2187], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py": ["\"\"\"Thread module emulating a subset of Java's threading model.\"\"\"\n\nimport os as _os\nimport sys as _sys\nimport _thread\n\nfrom time import monotonic as _time\nfrom _weakrefset import WeakSet\nfrom itertools import islice as _islice, count as _count\ntry:\n    from _collections import deque as _deque\nexcept ImportError:\n    from collections import deque as _deque\n\n# Note regarding PEP 8 compliant names\n#  This threading model was originally inspired by Java, and inherited\n# the convention of camelCase function and method names from that\n# language. Those original names are not in any imminent danger of\n# being deprecated (even for Py3k),so this module provides them as an\n# alias for the PEP 8 compliant names\n# Note that using the new PEP 8 compliant names facilitates substitution\n# with the multiprocessing module, which doesn't provide the old\n# Java inspired names.\n\n__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',\n           'enumerate', 'main_thread', 'TIMEOUT_MAX',\n           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',\n           'Barrier', 'BrokenBarrierError', 'Timer', 'ThreadError',\n           'setprofile', 'settrace', 'local', 'stack_size',\n           'excepthook', 'ExceptHookArgs']\n\n# Rename some stuff so \"from threading import *\" is safe\n_start_new_thread = _thread.start_new_thread\n_allocate_lock = _thread.allocate_lock\n_set_sentinel = _thread._set_sentinel\nget_ident = _thread.get_ident\ntry:\n    get_native_id = _thread.get_native_id\n    _HAVE_THREAD_NATIVE_ID = True\n    __all__.append('get_native_id')\nexcept AttributeError:\n    _HAVE_THREAD_NATIVE_ID = False\nThreadError = _thread.error\ntry:\n    _CRLock = _thread.RLock\nexcept AttributeError:\n    _CRLock = None\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n\n# Support for profile and trace hooks\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n    \"\"\"Set a profile function for all threads started from the threading module.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n\n    \"\"\"\n    global _profile_hook\n    _profile_hook = func\n\ndef settrace(func):\n    \"\"\"Set a trace function for all threads started from the threading module.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n\n    \"\"\"\n    global _trace_hook\n    _trace_hook = func\n\n# Synchronization classes\n\nLock = _allocate_lock\n\ndef RLock(*args, **kwargs):\n    \"\"\"Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    \"\"\"\n    if _CRLock is None:\n        return _PyRLock(*args, **kwargs)\n    return _CRLock(*args, **kwargs)\n\nclass _RLock:\n    \"\"\"This class implements reentrant lock objects.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it\n    again without blocking; the thread must release it once for each time it\n    has acquired it.\n\n    \"\"\"\n\n    def __init__(self):\n        self._block = _allocate_lock()\n        self._owner = None\n        self._count = 0\n\n    def __repr__(self):\n        owner = self._owner\n        try:\n            owner = _active[owner].name\n        except KeyError:\n            pass\n        return \"<%s %s.%s object owner=%r count=%d at %s>\" % (\n            \"locked\" if self._block.locked() else \"unlocked\",\n            self.__class__.__module__,\n            self.__class__.__qualname__,\n            owner,\n            self._count,\n            hex(id(self))\n        )\n\n    def acquire(self, blocking=True, timeout=-1):\n        \"\"\"Acquire a lock, blocking or non-blocking.\n\n        When invoked without arguments: if this thread already owns the lock,\n        increment the recursion level by one, and return immediately. Otherwise,\n        if another thread owns the lock, block until the lock is unlocked. Once\n        the lock is unlocked (not owned by any thread), then grab ownership, set\n        the recursion level to one, and return. If more than one thread is\n        blocked waiting until the lock is unlocked, only one at a time will be\n        able to grab ownership of the lock. There is no return value in this\n        case.\n\n        When invoked with the blocking argument set to true, do the same thing\n        as when called without arguments, and return true.\n\n        When invoked with the blocking argument set to false, do not block. If a\n        call without an argument would block, return false immediately;\n        otherwise, do the same thing as when called without arguments, and\n        return true.\n\n        When invoked with the floating-point timeout argument set to a positive\n        value, block for at most the number of seconds specified by timeout\n        and as long as the lock cannot be acquired.  Return true if the lock has\n        been acquired, false if the timeout has elapsed.\n\n        \"\"\"\n        me = get_ident()\n        if self._owner == me:\n            self._count += 1\n            return 1\n        rc = self._block.acquire(blocking, timeout)\n        if rc:\n            self._owner = me\n            self._count = 1\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a lock, decrementing the recursion level.\n\n        If after the decrement it is zero, reset the lock to unlocked (not owned\n        by any thread), and if any other threads are blocked waiting for the\n        lock to become unlocked, allow exactly one of them to proceed. If after\n        the decrement the recursion level is still nonzero, the lock remains\n        locked and owned by the calling thread.\n\n        Only call this method when the calling thread owns the lock. A\n        RuntimeError is raised if this method is called when the lock is\n        unlocked.\n\n        There is no return value.\n\n        \"\"\"\n        if self._owner != get_ident():\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        self._count = count = self._count - 1\n        if not count:\n            self._owner = None\n            self._block.release()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n    # Internal methods used by condition variables\n\n    def _acquire_restore(self, state):\n        self._block.acquire()\n        self._count, self._owner = state\n\n    def _release_save(self):\n        if self._count == 0:\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        count = self._count\n        self._count = 0\n        owner = self._owner\n        self._owner = None\n        self._block.release()\n        return (count, owner)\n\n    def _is_owned(self):\n        return self._owner == get_ident()\n\n_PyRLock = _RLock\n\n\nclass Condition:\n    \"\"\"Class that implements a condition variable.\n\n    A condition variable allows one or more threads to wait until they are\n    notified by another thread.\n\n    If the lock argument is given and not None, it must be a Lock or RLock\n    object, and it is used as the underlying lock. Otherwise, a new RLock object\n    is created and used as the underlying lock.\n\n    \"\"\"\n\n    def __init__(self, lock=None):\n        if lock is None:\n            lock = RLock()\n        self._lock = lock\n        # Export the lock's acquire() and release() methods\n        self.acquire = lock.acquire\n        self.release = lock.release\n        # If the lock defines _release_save() and/or _acquire_restore(),\n        # these override the default implementations (which just call\n        # release() and acquire() on the lock).  Ditto for _is_owned().\n        try:\n            self._release_save = lock._release_save\n        except AttributeError:\n            pass\n        try:\n            self._acquire_restore = lock._acquire_restore\n        except AttributeError:\n            pass\n        try:\n            self._is_owned = lock._is_owned\n        except AttributeError:\n            pass\n        self._waiters = _deque()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n    def __repr__(self):\n        return \"<Condition(%s, %d)>\" % (self._lock, len(self._waiters))\n\n    def _release_save(self):\n        self._lock.release()           # No state to save\n\n    def _acquire_restore(self, x):\n        self._lock.acquire()           # Ignore saved state\n\n    def _is_owned(self):\n        # Return True if lock is owned by current_thread.\n        # This method is called only if _lock doesn't have _is_owned().\n        if self._lock.acquire(0):\n            self._lock.release()\n            return False\n        else:\n            return True\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n                waiter.acquire()\n                gotit = True\n            else:\n                if timeout > 0:\n                    gotit = waiter.acquire(True, timeout)\n                else:\n                    gotit = waiter.acquire(False)\n            return gotit\n        finally:\n            self._acquire_restore(saved_state)\n            if not gotit:\n                try:\n                    self._waiters.remove(waiter)\n                except ValueError:\n                    pass\n\n    def wait_for(self, predicate, timeout=None):\n        \"\"\"Wait until a condition evaluates to True.\n\n        predicate should be a callable which result will be interpreted as a\n        boolean value.  A timeout may be provided giving the maximum time to\n        wait.\n\n        \"\"\"\n        endtime = None\n        waittime = timeout\n        result = predicate()\n        while not result:\n            if waittime is not None:\n                if endtime is None:\n                    endtime = _time() + waittime\n                else:\n                    waittime = endtime - _time()\n                    if waittime <= 0:\n                        break\n            self.wait(waittime)\n            result = predicate()\n        return result\n\n    def notify(self, n=1):\n        \"\"\"Wake up one or more threads waiting on this condition, if any.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method wakes up at most n of the threads waiting for the condition\n        variable; it is a no-op if no threads are waiting.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot notify on un-acquired lock\")\n        all_waiters = self._waiters\n        waiters_to_notify = _deque(_islice(all_waiters, n))\n        if not waiters_to_notify:\n            return\n        for waiter in waiters_to_notify:\n            waiter.release()\n            try:\n                all_waiters.remove(waiter)\n            except ValueError:\n                pass\n\n    def notify_all(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        If the calling thread has not acquired the lock when this method\n        is called, a RuntimeError is raised.\n\n        \"\"\"\n        self.notify(len(self._waiters))\n\n    notifyAll = notify_all\n\n\nclass Semaphore:\n    \"\"\"This class implements semaphore objects.\n\n    Semaphores manage a counter representing the number of release() calls minus\n    the number of acquire() calls, plus an initial value. The acquire() method\n    blocks if necessary until it can return without making the counter\n    negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    # After Tim Peters' semaphore class, but not quite the same (no maximum)\n\n    def __init__(self, value=1):\n        if value < 0:\n            raise ValueError(\"semaphore initial value must be >= 0\")\n        self._cond = Condition(Lock())\n        self._value = value\n\n    def acquire(self, blocking=True, timeout=None):\n        \"\"\"Acquire a semaphore, decrementing the internal counter by one.\n\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n\n        When invoked with a timeout other than None, it will block for at\n        most timeout seconds.  If acquire does not complete successfully in\n        that interval, return false.  Return true otherwise.\n\n        \"\"\"\n        if not blocking and timeout is not None:\n            raise ValueError(\"can't specify timeout for non-blocking acquire\")\n        rc = False\n        endtime = None\n        with self._cond:\n            while self._value == 0:\n                if not blocking:\n                    break\n                if timeout is not None:\n                    if endtime is None:\n                        endtime = _time() + timeout\n                    else:\n                        timeout = endtime - _time()\n                        if timeout <= 0:\n                            break\n                self._cond.wait(timeout)\n            else:\n                self._value -= 1\n                rc = True\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        \"\"\"\n        with self._cond:\n            self._value += 1\n            self._cond.notify()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass BoundedSemaphore(Semaphore):\n    \"\"\"Implements a bounded semaphore.\n\n    A bounded semaphore checks to make sure its current value doesn't exceed its\n    initial value. If it does, ValueError is raised. In most situations\n    semaphores are used to guard resources with limited capacity.\n\n    If the semaphore is released too many times it's a sign of a bug. If not\n    given, value defaults to 1.\n\n    Like regular semaphores, bounded semaphores manage a counter representing\n    the number of release() calls minus the number of acquire() calls, plus an\n    initial value. The acquire() method blocks if necessary until it can return\n    without making the counter negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    def __init__(self, value=1):\n        Semaphore.__init__(self, value)\n        self._initial_value = value\n\n    def release(self):\n        \"\"\"Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        If the number of releases exceeds the number of acquires,\n        raise a ValueError.\n\n        \"\"\"\n        with self._cond:\n            if self._value >= self._initial_value:\n                raise ValueError(\"Semaphore released too many times\")\n            self._value += 1\n            self._cond.notify()\n\n\nclass Event:\n    \"\"\"Class implementing event objects.\n\n    Events manage a flag that can be set to true with the set() method and reset\n    to false with the clear() method. The wait() method blocks until the flag is\n    true.  The flag is initially false.\n\n    \"\"\"\n\n    # After Tim Peters' event class (without is_posted())\n\n    def __init__(self):\n        self._cond = Condition(Lock())\n        self._flag = False\n\n    def _reset_internal_locks(self):\n        # private!  called by Thread._reset_internal_locks by _after_fork()\n        self._cond.__init__(Lock())\n\n    def is_set(self):\n        \"\"\"Return true if and only if the internal flag is true.\"\"\"\n        return self._flag\n\n    isSet = is_set\n\n    def set(self):\n        \"\"\"Set the internal flag to true.\n\n        All threads waiting for it to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        \"\"\"\n        with self._cond:\n            self._flag = True\n            self._cond.notify_all()\n\n    def clear(self):\n        \"\"\"Reset the internal flag to false.\n\n        Subsequently, threads calling wait() will block until set() is called to\n        set the internal flag to true again.\n\n        \"\"\"\n        with self._cond:\n            self._flag = False\n\n    def wait(self, timeout=None):\n        \"\"\"Block until the internal flag is true.\n\n        If the internal flag is true on entry, return immediately. Otherwise,\n        block until another thread calls set() to set the flag to true, or until\n        the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        This method returns the internal flag on exit, so it will always return\n        True except if a timeout is given and the operation times out.\n\n        \"\"\"\n        with self._cond:\n            signaled = self._flag\n            if not signaled:\n                signaled = self._cond.wait(timeout)\n            return signaled\n\n\n# A barrier class.  Inspired in part by the pthread_barrier_* api and\n# the CyclicBarrier class from Java.  See\n# http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and\n# http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/\n#        CyclicBarrier.html\n# for information.\n# We maintain two main states, 'filling' and 'draining' enabling the barrier\n# to be cyclic.  Threads are not allowed into it until it has fully drained\n# since the previous cycle.  In addition, a 'resetting' state exists which is\n# similar to 'draining' except that threads leave with a BrokenBarrierError,\n# and a 'broken' state in which all threads get the exception.\nclass Barrier:\n    \"\"\"Implements a Barrier.\n\n    Useful for synchronizing a fixed number of threads at known synchronization\n    points.  Threads block on 'wait()' and are simultaneously awoken once they\n    have all made that call.\n\n    \"\"\"\n\n    def __init__(self, parties, action=None, timeout=None):\n        \"\"\"Create a barrier, initialised to 'parties' threads.\n\n        'action' is a callable which, when supplied, will be called by one of\n        the threads after they have all entered the barrier and just prior to\n        releasing them all. If a 'timeout' is provided, it is used as the\n        default for all subsequent 'wait()' calls.\n\n        \"\"\"\n        self._cond = Condition(Lock())\n        self._action = action\n        self._timeout = timeout\n        self._parties = parties\n        self._state = 0 #0 filling, 1, draining, -1 resetting, -2 broken\n        self._count = 0\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for the barrier.\n\n        When the specified number of threads have started waiting, they are all\n        simultaneously awoken. If an 'action' was provided for the barrier, one\n        of the threads will have executed that callback prior to returning.\n        Returns an individual index number from 0 to 'parties-1'.\n\n        \"\"\"\n        if timeout is None:\n            timeout = self._timeout\n        with self._cond:\n            self._enter() # Block while the barrier drains.\n            index = self._count\n            self._count += 1\n            try:\n                if index + 1 == self._parties:\n                    # We release the barrier\n                    self._release()\n                else:\n                    # We wait until someone releases us\n                    self._wait(timeout)\n                return index\n            finally:\n                self._count -= 1\n                # Wake up any threads waiting for barrier to drain.\n                self._exit()\n\n    # Block until the barrier is ready for us, or raise an exception\n    # if it is broken.\n    def _enter(self):\n        while self._state in (-1, 1):\n            # It is draining or resetting, wait until done\n            self._cond.wait()\n        #see if the barrier is in a broken state\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 0\n\n    # Optionally run the 'action' and release the threads waiting\n    # in the barrier.\n    def _release(self):\n        try:\n            if self._action:\n                self._action()\n            # enter draining state\n            self._state = 1\n            self._cond.notify_all()\n        except:\n            #an exception during the _action handler.  Break and reraise\n            self._break()\n            raise\n\n    # Wait in the barrier until we are released.  Raise an exception\n    # if the barrier is reset or broken.\n    def _wait(self, timeout):\n        if not self._cond.wait_for(lambda : self._state != 0, timeout):\n            #timed out.  Break the barrier\n            self._break()\n            raise BrokenBarrierError\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 1\n\n    # If we are the last thread to exit the barrier, signal any threads\n    # waiting for the barrier to drain.\n    def _exit(self):\n        if self._count == 0:\n            if self._state in (-1, 1):\n                #resetting or draining\n                self._state = 0\n                self._cond.notify_all()\n\n    def reset(self):\n        \"\"\"Reset the barrier to the initial state.\n\n        Any threads currently waiting will get the BrokenBarrier exception\n        raised.\n\n        \"\"\"\n        with self._cond:\n            if self._count > 0:\n                if self._state == 0:\n                    #reset the barrier, waking up threads\n                    self._state = -1\n                elif self._state == -2:\n                    #was broken, set it to reset state\n                    #which clears when the last thread exits\n                    self._state = -1\n            else:\n                self._state = 0\n            self._cond.notify_all()\n\n    def abort(self):\n        \"\"\"Place the barrier into a 'broken' state.\n\n        Useful in case of error.  Any currently waiting threads and threads\n        attempting to 'wait()' will have BrokenBarrierError raised.\n\n        \"\"\"\n        with self._cond:\n            self._break()\n\n    def _break(self):\n        # An internal error was detected.  The barrier is set to\n        # a broken state all parties awakened.\n        self._state = -2\n        self._cond.notify_all()\n\n    @property\n    def parties(self):\n        \"\"\"Return the number of threads required to trip the barrier.\"\"\"\n        return self._parties\n\n    @property\n    def n_waiting(self):\n        \"\"\"Return the number of threads currently waiting at the barrier.\"\"\"\n        # We don't need synchronization here since this is an ephemeral result\n        # anyway.  It returns the correct value in the steady state.\n        if self._state == 0:\n            return self._count\n        return 0\n\n    @property\n    def broken(self):\n        \"\"\"Return True if the barrier is in a broken state.\"\"\"\n        return self._state == -2\n\n# exception raised by the Barrier class\nclass BrokenBarrierError(RuntimeError):\n    pass\n\n\n# Helper to generate new thread names\n_counter = _count().__next__\n_counter() # Consume 0 so first non-main thread has id 1.\ndef _newname(template=\"Thread-%d\"):\n    return template % _counter()\n\n# Active thread administration\n_active_limbo_lock = _allocate_lock()\n_active = {}    # maps thread id to Thread object\n_limbo = {}\n_dangling = WeakSet()\n# Set of Thread._tstate_lock locks of non-daemon threads used by _shutdown()\n# to wait until all Python thread states get deleted:\n# see Thread._set_tstate_lock().\n_shutdown_locks_lock = _allocate_lock()\n_shutdown_locks = set()\n\n# Main class for threads\n\nclass Thread:\n    \"\"\"A class that represents a thread of control.\n\n    This class can be safely subclassed in a limited fashion. There are two ways\n    to specify the activity: by passing a callable object to the constructor, or\n    by overriding the run() method in a subclass.\n\n    \"\"\"\n\n    _initialized = False\n\n    def __init__(self, group=None, target=None, name=None,\n                 args=(), kwargs=None, *, daemon=None):\n        \"\"\"This constructor should always be called with keyword arguments. Arguments are:\n\n        *group* should be None; reserved for future extension when a ThreadGroup\n        class is implemented.\n\n        *target* is the callable object to be invoked by the run()\n        method. Defaults to None, meaning nothing is called.\n\n        *name* is the thread name. By default, a unique name is constructed of\n        the form \"Thread-N\" where N is a small decimal number.\n\n        *args* is the argument tuple for the target invocation. Defaults to ().\n\n        *kwargs* is a dictionary of keyword arguments for the target\n        invocation. Defaults to {}.\n\n        If a subclass overrides the constructor, it must make sure to invoke\n        the base class constructor (Thread.__init__()) before doing anything\n        else to the thread.\n\n        \"\"\"\n        assert group is None, \"group argument must be None for now\"\n        if kwargs is None:\n            kwargs = {}\n        self._target = target\n        self._name = str(name or _newname())\n        self._args = args\n        self._kwargs = kwargs\n        if daemon is not None:\n            self._daemonic = daemon\n        else:\n            self._daemonic = current_thread().daemon\n        self._ident = None\n        if _HAVE_THREAD_NATIVE_ID:\n            self._native_id = None\n        self._tstate_lock = None\n        self._started = Event()\n        self._is_stopped = False\n        self._initialized = True\n        # Copy of sys.stderr used by self._invoke_excepthook()\n        self._stderr = _sys.stderr\n        self._invoke_excepthook = _make_invoke_excepthook()\n        # For debugging and _after_fork()\n        _dangling.add(self)\n\n    def _reset_internal_locks(self, is_alive):\n        # private!  Called by _after_fork() to reset our internal locks as\n        # they may be in an invalid state leading to a deadlock or crash.\n        self._started._reset_internal_locks()\n        if is_alive:\n            self._set_tstate_lock()\n        else:\n            # The thread isn't alive after fork: it doesn't have a tstate\n            # anymore.\n            self._is_stopped = True\n            self._tstate_lock = None\n\n    def __repr__(self):\n        assert self._initialized, \"Thread.__init__() was not called\"\n        status = \"initial\"\n        if self._started.is_set():\n            status = \"started\"\n        self.is_alive() # easy way to get ._is_stopped set when appropriate\n        if self._is_stopped:\n            status = \"stopped\"\n        if self._daemonic:\n            status += \" daemon\"\n        if self._ident is not None:\n            status += \" %s\" % self._ident\n        return \"<%s(%s, %s)>\" % (self.__class__.__name__, self._name, status)\n\n    def start(self):\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n        same thread object.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n            raise RuntimeError(\"threads can only be started once\")\n        with _active_limbo_lock:\n            _limbo[self] = self\n        try:\n            _start_new_thread(self._bootstrap, ())\n        except Exception:\n            with _active_limbo_lock:\n                del _limbo[self]\n            raise\n        self._started.wait()\n\n    def run(self):\n        \"\"\"Method representing the thread's activity.\n\n        You may override this method in a subclass. The standard run() method\n        invokes the callable object passed to the object's constructor as the\n        target argument, if any, with sequential and keyword arguments taken\n        from the args and kwargs arguments, respectively.\n\n        \"\"\"\n        try:\n            if self._target:\n                self._target(*self._args, **self._kwargs)\n        finally:\n            # Avoid a refcycle if the thread is running a function with\n            # an argument that has a member that points to the thread.\n            del self._target, self._args, self._kwargs\n\n    def _bootstrap(self):\n        # Wrapper around the real bootstrap code that ignores\n        # exceptions during interpreter cleanup.  Those typically\n        # happen when a daemon thread wakes up at an unfortunate\n        # moment, finds the world around it destroyed, and raises some\n        # random exception *** while trying to report the exception in\n        # _bootstrap_inner() below ***.  Those random exceptions\n        # don't help anybody, and they confuse users, so we suppress\n        # them.  We suppress them only when it appears that the world\n        # indeed has already been destroyed, so that exceptions in\n        # _bootstrap_inner() during normal business hours are properly\n        # reported.  Also, we only suppress them for daemonic threads;\n        # if a non-daemonic encounters this, something else is wrong.\n        try:\n            self._bootstrap_inner()\n        except:\n            if self._daemonic and _sys is None:\n                return\n            raise\n\n    def _set_ident(self):\n        self._ident = get_ident()\n\n    if _HAVE_THREAD_NATIVE_ID:\n        def _set_native_id(self):\n            self._native_id = get_native_id()\n\n    def _set_tstate_lock(self):\n        \"\"\"\n        Set a lock object which will be released by the interpreter when\n        the underlying thread state (see pystate.h) gets deleted.\n        \"\"\"\n        self._tstate_lock = _set_sentinel()\n        self._tstate_lock.acquire()\n\n        if not self.daemon:\n            with _shutdown_locks_lock:\n                _shutdown_locks.add(self._tstate_lock)\n\n    def _bootstrap_inner(self):\n        try:\n            self._set_ident()\n            self._set_tstate_lock()\n            if _HAVE_THREAD_NATIVE_ID:\n                self._set_native_id()\n            self._started.set()\n            with _active_limbo_lock:\n                _active[self._ident] = self\n                del _limbo[self]\n\n            if _trace_hook:\n                _sys.settrace(_trace_hook)\n            if _profile_hook:\n                _sys.setprofile(_profile_hook)\n\n            try:\n                self.run()\n            except:\n                self._invoke_excepthook(self)\n        finally:\n            with _active_limbo_lock:\n                try:\n                    # We don't call self._delete() because it also\n                    # grabs _active_limbo_lock.\n                    del _active[get_ident()]\n                except:\n                    pass\n\n    def _stop(self):\n        # After calling ._stop(), .is_alive() returns False and .join() returns\n        # immediately.  ._tstate_lock must be released before calling ._stop().\n        #\n        # Normal case:  C code at the end of the thread's life\n        # (release_sentinel in _threadmodule.c) releases ._tstate_lock, and\n        # that's detected by our ._wait_for_tstate_lock(), called by .join()\n        # and .is_alive().  Any number of threads _may_ call ._stop()\n        # simultaneously (for example, if multiple threads are blocked in\n        # .join() calls), and they're not serialized.  That's harmless -\n        # they'll just make redundant rebindings of ._is_stopped and\n        # ._tstate_lock.  Obscure:  we rebind ._tstate_lock last so that the\n        # \"assert self._is_stopped\" in ._wait_for_tstate_lock() always works\n        # (the assert is executed only if ._tstate_lock is None).\n        #\n        # Special case:  _main_thread releases ._tstate_lock via this\n        # module's _shutdown() function.\n        lock = self._tstate_lock\n        if lock is not None:\n            assert not lock.locked()\n        self._is_stopped = True\n        self._tstate_lock = None\n        if not self.daemon:\n            with _shutdown_locks_lock:\n                _shutdown_locks.discard(lock)\n\n    def _delete(self):\n        \"Remove current thread from the dict of currently running threads.\"\n        with _active_limbo_lock:\n            del _active[get_ident()]\n            # There must not be any python code between the previous line\n            # and after the lock is released.  Otherwise a tracing function\n            # could try to acquire the lock again in the same thread, (in\n            # current_thread()), and would block.\n\n    def join(self, timeout=None):\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n        called terminates -- either normally or through an unhandled exception\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof). As join() always returns None, you must call\n        is_alive() after join() to decide whether a timeout happened -- if the\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n        thread as that would cause a deadlock. It is also an error to join() a\n        thread before it has been started and attempts to do so raises the same\n        exception.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if not self._started.is_set():\n            raise RuntimeError(\"cannot join thread before it is started\")\n        if self is current_thread():\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n            self._wait_for_tstate_lock()\n        else:\n            # the behavior of a negative timeout isn't documented, but\n            # historically .join(timeout=x) for x<0 has acted as if timeout=0\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n\n    def _wait_for_tstate_lock(self, block=True, timeout=-1):\n        # Issue #18808: wait for the thread state to be gone.\n        # At the end of the thread's life, after all knowledge of the thread\n        # is removed from C data structures, C code releases our _tstate_lock.\n        # This method passes its arguments to _tstate_lock.acquire().\n        # If the lock is acquired, the C code is done, and self._stop() is\n        # called.  That sets ._is_stopped to True, and ._tstate_lock to None.\n        lock = self._tstate_lock\n        if lock is None:  # already determined that the C code is done\n            assert self._is_stopped\n        elif lock.acquire(block, timeout):\n            lock.release()\n            self._stop()\n\n    @property\n    def name(self):\n        \"\"\"A string used for identification purposes only.\n\n        It has no semantics. Multiple threads may be given the same name. The\n        initial name is set by the constructor.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert self._initialized, \"Thread.__init__() not called\"\n        self._name = str(name)\n\n    @property\n    def ident(self):\n        \"\"\"Thread identifier of this thread or None if it has not been started.\n\n        This is a nonzero integer. See the get_ident() function. Thread\n        identifiers may be recycled when a thread exits and another thread is\n        created. The identifier is available even after the thread has exited.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._ident\n\n    if _HAVE_THREAD_NATIVE_ID:\n        @property\n        def native_id(self):\n            \"\"\"Native integral thread ID of this thread, or None if it has not been started.\n\n            This is a non-negative integer. See the get_native_id() function.\n            This represents the Thread ID as reported by the kernel.\n\n            \"\"\"\n            assert self._initialized, \"Thread.__init__() not called\"\n            return self._native_id\n\n    def is_alive(self):\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n        after the run() method terminates. The module function enumerate()\n        returns a list of all alive threads.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        if self._is_stopped or not self._started.is_set():\n            return False\n        self._wait_for_tstate_lock(False)\n        return not self._is_stopped\n\n    def isAlive(self):\n        \"\"\"Return whether the thread is alive.\n\n        This method is deprecated, use is_alive() instead.\n        \"\"\"\n        import warnings\n        warnings.warn('isAlive() is deprecated, use is_alive() instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.is_alive()\n\n    @property\n    def daemon(self):\n        \"\"\"A boolean value indicating whether this thread is a daemon thread.\n\n        This must be set before start() is called, otherwise RuntimeError is\n        raised. Its initial value is inherited from the creating thread; the\n        main thread is not a daemon thread and therefore all threads created in\n        the main thread default to daemon = False.\n\n        The entire Python program exits when only daemon threads are left.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._daemonic\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if self._started.is_set():\n            raise RuntimeError(\"cannot set daemon status of active thread\")\n        self._daemonic = daemonic\n\n    def isDaemon(self):\n        return self.daemon\n\n    def setDaemon(self, daemonic):\n        self.daemon = daemonic\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n\ntry:\n    from _thread import (_excepthook as excepthook,\n                         _ExceptHookArgs as ExceptHookArgs)\nexcept ImportError:\n    # Simple Python implementation if _thread._excepthook() is not available\n    from traceback import print_exception as _print_exception\n    from collections import namedtuple\n\n    _ExceptHookArgs = namedtuple(\n        'ExceptHookArgs',\n        'exc_type exc_value exc_traceback thread')\n\n    def ExceptHookArgs(args):\n        return _ExceptHookArgs(*args)\n\n    def excepthook(args, /):\n        \"\"\"\n        Handle uncaught Thread.run() exception.\n        \"\"\"\n        if args.exc_type == SystemExit:\n            # silently ignore SystemExit\n            return\n\n        if _sys is not None and _sys.stderr is not None:\n            stderr = _sys.stderr\n        elif args.thread is not None:\n            stderr = args.thread._stderr\n            if stderr is None:\n                # do nothing if sys.stderr is None and sys.stderr was None\n                # when the thread was created\n                return\n        else:\n            # do nothing if sys.stderr is None and args.thread is None\n            return\n\n        if args.thread is not None:\n            name = args.thread.name\n        else:\n            name = get_ident()\n        print(f\"Exception in thread {name}:\",\n              file=stderr, flush=True)\n        _print_exception(args.exc_type, args.exc_value, args.exc_traceback,\n                         file=stderr)\n        stderr.flush()\n\n\ndef _make_invoke_excepthook():\n    # Create a local namespace to ensure that variables remain alive\n    # when _invoke_excepthook() is called, even if it is called late during\n    # Python shutdown. It is mostly needed for daemon threads.\n\n    old_excepthook = excepthook\n    old_sys_excepthook = _sys.excepthook\n    if old_excepthook is None:\n        raise RuntimeError(\"threading.excepthook is None\")\n    if old_sys_excepthook is None:\n        raise RuntimeError(\"sys.excepthook is None\")\n\n    sys_exc_info = _sys.exc_info\n    local_print = print\n    local_sys = _sys\n\n    def invoke_excepthook(thread):\n        global excepthook\n        try:\n            hook = excepthook\n            if hook is None:\n                hook = old_excepthook\n\n            args = ExceptHookArgs([*sys_exc_info(), thread])\n\n            hook(args)\n        except Exception as exc:\n            exc.__suppress_context__ = True\n            del exc\n\n            if local_sys is not None and local_sys.stderr is not None:\n                stderr = local_sys.stderr\n            else:\n                stderr = thread._stderr\n\n            local_print(\"Exception in threading.excepthook:\",\n                        file=stderr, flush=True)\n\n            if local_sys is not None and local_sys.excepthook is not None:\n                sys_excepthook = local_sys.excepthook\n            else:\n                sys_excepthook = old_sys_excepthook\n\n            sys_excepthook(*sys_exc_info())\n        finally:\n            # Break reference cycle (exception stored in a variable)\n            args = None\n\n    return invoke_excepthook\n\n\n# The timer class was contributed by Itamar Shtull-Trauring\n\nclass Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n            t = Timer(30.0, f, args=None, kwargs=None)\n            t.start()\n            t.cancel()     # stop the timer's action if it's still waiting\n\n    \"\"\"\n\n    def __init__(self, interval, function, args=None, kwargs=None):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args if args is not None else []\n        self.kwargs = kwargs if kwargs is not None else {}\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet.\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.is_set():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n\n# Special thread class to represent the main thread\n\nclass _MainThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=\"MainThread\", daemon=False)\n        self._set_tstate_lock()\n        self._started.set()\n        self._set_ident()\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n\n# Dummy thread class to represent threads not started here.\n# These aren't garbage collected when they die, nor can they be waited for.\n# If they invoke anything in threading.py that calls current_thread(), they\n# leave an entry in the _active dict forever after.\n# Their purpose is to return *something* from current_thread().\n# They are marked as daemon threads so we won't wait for them\n# when we exit (conform previous semantics).\n\nclass _DummyThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=_newname(\"Dummy-%d\"), daemon=True)\n\n        self._started.set()\n        self._set_ident()\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n    def _stop(self):\n        pass\n\n    def is_alive(self):\n        assert not self._is_stopped and self._started.is_set()\n        return True\n\n    def join(self, timeout=None):\n        assert False, \"cannot join a dummy thread\"\n\n\n# Global API functions\n\ndef current_thread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    If the caller's thread of control was not created through the threading\n    module, a dummy thread object with limited functionality is returned.\n\n    \"\"\"\n    try:\n        return _active[get_ident()]\n    except KeyError:\n        return _DummyThread()\n\ncurrentThread = current_thread\n\ndef active_count():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    The returned count is equal to the length of the list returned by\n    enumerate().\n\n    \"\"\"\n    with _active_limbo_lock:\n        return len(_active) + len(_limbo)\n\nactiveCount = active_count\n\ndef _enumerate():\n    # Same as enumerate(), but without the lock. Internal use only.\n    return list(_active.values()) + list(_limbo.values())\n\ndef enumerate():\n    \"\"\"Return a list of all Thread objects currently alive.\n\n    The list includes daemonic threads, dummy thread objects created by\n    current_thread(), and the main thread. It excludes terminated threads and\n    threads that have not yet been started.\n\n    \"\"\"\n    with _active_limbo_lock:\n        return list(_active.values()) + list(_limbo.values())\n\nfrom _thread import stack_size\n\n# Create the main thread object,\n# and make it available for the interpreter\n# (Py_Main) as threading._shutdown.\n\n_main_thread = _MainThread()\n\ndef _shutdown():\n    \"\"\"\n    Wait until the Python thread state of all non-daemon threads get deleted.\n    \"\"\"\n    # Obscure:  other threads may be waiting to join _main_thread.  That's\n    # dubious, but some code does it.  We can't wait for C code to release\n    # the main thread's tstate_lock - that won't happen until the interpreter\n    # is nearly dead.  So we release it here.  Note that just calling _stop()\n    # isn't enough:  other threads may already be waiting on _tstate_lock.\n    if _main_thread._is_stopped:\n        # _shutdown() was already called\n        return\n\n    # Main thread\n    tlock = _main_thread._tstate_lock\n    # The main thread isn't finished yet, so its thread state lock can't have\n    # been released.\n    assert tlock is not None\n    assert tlock.locked()\n    tlock.release()\n    _main_thread._stop()\n\n    # Join all non-deamon threads\n    while True:\n        with _shutdown_locks_lock:\n            locks = list(_shutdown_locks)\n            _shutdown_locks.clear()\n\n        if not locks:\n            break\n\n        for lock in locks:\n            # mimick Thread.join()\n            lock.acquire()\n            lock.release()\n\n        # new threads can be spawned while we were waiting for the other\n        # threads to complete\n\n\ndef main_thread():\n    \"\"\"Return the main thread object.\n\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    \"\"\"\n    return _main_thread\n\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\n\ntry:\n    from _thread import _local as local\nexcept ImportError:\n    from _threading_local import local\n\n\ndef _after_fork():\n    \"\"\"\n    Cleanup threading module state that should not exist after a fork.\n    \"\"\"\n    # Reset _active_limbo_lock, in case we forked while the lock was held\n    # by another (non-forked) thread.  http://bugs.python.org/issue874900\n    global _active_limbo_lock, _main_thread\n    global _shutdown_locks_lock, _shutdown_locks\n    _active_limbo_lock = _allocate_lock()\n\n    # fork() only copied the current thread; clear references to others.\n    new_active = {}\n    current = current_thread()\n    _main_thread = current\n\n    # reset _shutdown() locks: threads re-register their _tstate_lock below\n    _shutdown_locks_lock = _allocate_lock()\n    _shutdown_locks = set()\n\n    with _active_limbo_lock:\n        # Dangling thread instances must still have their locks reset,\n        # because someone may join() them.\n        threads = set(_enumerate())\n        threads.update(_dangling)\n        for thread in threads:\n            # Any lock/condition variable may be currently locked or in an\n            # invalid state, so we reinitialize them.\n            if thread is current:\n                # There is only one active thread. We reset the ident to\n                # its new value since it can have changed.\n                thread._reset_internal_locks(True)\n                ident = get_ident()\n                thread._ident = ident\n                new_active[ident] = thread\n            else:\n                # All the others are already stopped.\n                thread._reset_internal_locks(False)\n                thread._stop()\n\n        _limbo.clear()\n        _active.clear()\n        _active.update(new_active)\n        assert len(_active) == 1\n\n\nif hasattr(_os, \"register_at_fork\"):\n    _os.register_at_fork(after_in_child=_after_fork)\n", 1458], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py": ["# Access WeakSet through the weakref module.\n# This code is separated-out because it is needed\n# by abc.py to load everything else at startup.\n\nfrom _weakref import ref\n\n__all__ = ['WeakSet']\n\n\nclass _IterationGuard:\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n\n    def __enter__(self):\n        w = self.weakcontainer()\n        if w is not None:\n            w._iterating.add(self)\n        return self\n\n    def __exit__(self, e, t, b):\n        w = self.weakcontainer()\n        if w is not None:\n            s = w._iterating\n            s.remove(self)\n            if not s:\n                w._commit_removals()\n\n\nclass WeakSet:\n    def __init__(self, data=None):\n        self.data = set()\n        def _remove(item, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(item)\n                else:\n                    self.data.discard(item)\n        self._remove = _remove\n        # A list of keys to be removed\n        self._pending_removals = []\n        self._iterating = set()\n        if data is not None:\n            self.update(data)\n\n    def _commit_removals(self):\n        l = self._pending_removals\n        discard = self.data.discard\n        while l:\n            discard(l.pop())\n\n    def __iter__(self):\n        with _IterationGuard(self):\n            for itemref in self.data:\n                item = itemref()\n                if item is not None:\n                    # Caveat: the iterator will keep a strong reference to\n                    # `item` until it is resumed or closed.\n                    yield item\n\n    def __len__(self):\n        return len(self.data) - len(self._pending_removals)\n\n    def __contains__(self, item):\n        try:\n            wr = ref(item)\n        except TypeError:\n            return False\n        return wr in self.data\n\n    def __reduce__(self):\n        return (self.__class__, (list(self),),\n                getattr(self, '__dict__', None))\n\n    def add(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.add(ref(item, self._remove))\n\n    def clear(self):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.clear()\n\n    def copy(self):\n        return self.__class__(self)\n\n    def pop(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            try:\n                itemref = self.data.pop()\n            except KeyError:\n                raise KeyError('pop from empty WeakSet') from None\n            item = itemref()\n            if item is not None:\n                return item\n\n    def remove(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.remove(ref(item))\n\n    def discard(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.discard(ref(item))\n\n    def update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        for element in other:\n            self.add(element)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def difference(self, other):\n        newset = self.copy()\n        newset.difference_update(other)\n        return newset\n    __sub__ = difference\n\n    def difference_update(self, other):\n        self.__isub__(other)\n    def __isub__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.difference_update(ref(item) for item in other)\n        return self\n\n    def intersection(self, other):\n        return self.__class__(item for item in other if item in self)\n    __and__ = intersection\n\n    def intersection_update(self, other):\n        self.__iand__(other)\n    def __iand__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.intersection_update(ref(item) for item in other)\n        return self\n\n    def issubset(self, other):\n        return self.data.issubset(ref(item) for item in other)\n    __le__ = issubset\n\n    def __lt__(self, other):\n        return self.data < set(map(ref, other))\n\n    def issuperset(self, other):\n        return self.data.issuperset(ref(item) for item in other)\n    __ge__ = issuperset\n\n    def __gt__(self, other):\n        return self.data > set(map(ref, other))\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.data == set(map(ref, other))\n\n    def symmetric_difference(self, other):\n        newset = self.copy()\n        newset.symmetric_difference_update(other)\n        return newset\n    __xor__ = symmetric_difference\n\n    def symmetric_difference_update(self, other):\n        self.__ixor__(other)\n    def __ixor__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.symmetric_difference_update(ref(item, self._remove) for item in other)\n        return self\n\n    def union(self, other):\n        return self.__class__(e for s in (self, other) for e in s)\n    __or__ = union\n\n    def isdisjoint(self, other):\n        return len(self.intersection(other)) == 0\n\n    def __repr__(self):\n        return repr(self.data)\n", 199], "/home/edx/PycharmProjects/examples/threads/race_conditions.py": ["import time\nimport logging\nimport threading\nimport concurrent.futures\n\nfrom pathlib import Path\nfrom viztracer import VizTracer\n\nfrom threads.utils import ThreadInfo, timeit\n\n\nclass FakeDatabase:\n    def __init__(self):\n        self.value = 0\n        self._lock = threading.Lock()\n\n    @timeit\n    def update(self, name):\n        thread_info = ThreadInfo()\n        logging.info(\"Thread {}: starting update, value {}\".format(thread_info, self.value))\n        with self._lock:\n            logging.info(\"Thread %s has lock\", name)\n            local_copy = self.value\n            local_copy += 1\n            time.sleep(0.1)\n            self.value = local_copy\n        logging.info(\"Thread %s after release\", name)\n        logging.info(\"Thread {}: finishing update, value {}\".format(name, self.value))\n\n\n@timeit\ndef main():\n    _format = \"%(asctime)s.%(msecs)03d: %(message)s\"\n    logging.basicConfig(format=_format, level=logging.INFO, datefmt=\"%H:%M:%S\")\n\n    database = FakeDatabase()\n    logging.info(\"Testing update. Starting value is %d.\", database.value)\n    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:\n        for index in range(3):\n            executor.submit(database.update, index)\n    logging.info(\"Testing update. Ending value is %d.\", database.value)\n\n\nif __name__ == \"__main__\":\n    out_file = Path(__file__).stem + '.json'\n    with VizTracer(output_file=out_file) as tracer:\n        main()\n", 47], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py": ["\"\"\"Common operations on Posix pathnames.\n\nInstead of importing this module directly, import os and refer to\nthis module as os.path.  The \"os.path\" name is an alias for this\nmodule on Posix systems; on other systems (e.g. Windows),\nos.path provides the same operations in a manner specific to that\nplatform, and is an alias to another module (e.g. ntpath).\n\nSome of this can actually be useful on non-Posix systems too, e.g.\nfor manipulation of the pathname component of URLs.\n\"\"\"\n\n# Strings representing various path-related bits and pieces.\n# These are primarily for export; internally, they are hardcoded.\n# Should be set before imports for resolving cyclic dependency.\ncurdir = '.'\npardir = '..'\nextsep = '.'\nsep = '/'\npathsep = ':'\ndefpath = '/bin:/usr/bin'\naltsep = None\ndevnull = '/dev/null'\n\nimport os\nimport sys\nimport stat\nimport genericpath\nfrom genericpath import *\n\n__all__ = [\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"split\",\"splitext\",\n           \"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n           \"getatime\",\"getctime\",\"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n           \"ismount\", \"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n           \"samefile\",\"sameopenfile\",\"samestat\",\n           \"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\"extsep\",\n           \"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\",\n           \"commonpath\"]\n\n\ndef _get_sep(path):\n    if isinstance(path, bytes):\n        return b'/'\n    else:\n        return '/'\n\n# Normalize the case of a pathname.  Trivial in Posix, string.lower on Mac.\n# On MS-DOS this may also turn slashes into backslashes; however, other\n# normalizations (such as optimizing '../' away) are not allowed\n# (another function should be defined to do that).\n\ndef normcase(s):\n    \"\"\"Normalize case of pathname.  Has no effect under Posix\"\"\"\n    return os.fspath(s)\n\n\n# Return whether a path is absolute.\n# Trivial in Posix, harder on the Mac or MS-DOS.\n\ndef isabs(s):\n    \"\"\"Test whether a path is absolute\"\"\"\n    s = os.fspath(s)\n    sep = _get_sep(s)\n    return s.startswith(sep)\n\n\n# Join pathnames.\n# Ignore the previous parts if a part is absolute.\n# Insert a '/' unless the first part is empty or already ends in '/'.\n\ndef join(a, *p):\n    \"\"\"Join two or more pathname components, inserting '/' as needed.\n    If any component is an absolute path, all previous path components\n    will be discarded.  An empty last part will result in a path that\n    ends with a separator.\"\"\"\n    a = os.fspath(a)\n    sep = _get_sep(a)\n    path = a\n    try:\n        if not p:\n            path[:0] + sep  #23780: Ensure compatible data type even if p is null.\n        for b in map(os.fspath, p):\n            if b.startswith(sep):\n                path = b\n            elif not path or path.endswith(sep):\n                path += b\n            else:\n                path += sep + b\n    except (TypeError, AttributeError, BytesWarning):\n        genericpath._check_arg_types('join', a, *p)\n        raise\n    return path\n\n\n# Split a path in head (everything up to the last '/') and tail (the\n# rest).  If the path ends in '/', tail will be empty.  If there is no\n# '/' in the path, head  will be empty.\n# Trailing '/'es are stripped from head unless it is the root.\n\ndef split(p):\n    \"\"\"Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is\n    everything after the final slash.  Either part may be empty.\"\"\"\n    p = os.fspath(p)\n    sep = _get_sep(p)\n    i = p.rfind(sep) + 1\n    head, tail = p[:i], p[i:]\n    if head and head != sep*len(head):\n        head = head.rstrip(sep)\n    return head, tail\n\n\n# Split a path in root and extension.\n# The extension is everything starting at the last dot in the last\n# pathname component; the root is everything before that.\n# It is always true that root + ext == p.\n\ndef splitext(p):\n    p = os.fspath(p)\n    if isinstance(p, bytes):\n        sep = b'/'\n        extsep = b'.'\n    else:\n        sep = '/'\n        extsep = '.'\n    return genericpath._splitext(p, sep, None, extsep)\nsplitext.__doc__ = genericpath._splitext.__doc__\n\n# Split a pathname into a drive specification and the rest of the\n# path.  Useful on DOS/Windows/NT; on Unix, the drive is always empty.\n\ndef splitdrive(p):\n    \"\"\"Split a pathname into drive and path. On Posix, drive is always\n    empty.\"\"\"\n    p = os.fspath(p)\n    return p[:0], p\n\n\n# Return the tail (basename) part of a path, same as split(path)[1].\n\ndef basename(p):\n    \"\"\"Returns the final component of a pathname\"\"\"\n    p = os.fspath(p)\n    sep = _get_sep(p)\n    i = p.rfind(sep) + 1\n    return p[i:]\n\n\n# Return the head (dirname) part of a path, same as split(path)[0].\n\ndef dirname(p):\n    \"\"\"Returns the directory component of a pathname\"\"\"\n    p = os.fspath(p)\n    sep = _get_sep(p)\n    i = p.rfind(sep) + 1\n    head = p[:i]\n    if head and head != sep*len(head):\n        head = head.rstrip(sep)\n    return head\n\n\n# Is a path a symbolic link?\n# This will always return false on systems where os.lstat doesn't exist.\n\ndef islink(path):\n    \"\"\"Test whether a path is a symbolic link\"\"\"\n    try:\n        st = os.lstat(path)\n    except (OSError, ValueError, AttributeError):\n        return False\n    return stat.S_ISLNK(st.st_mode)\n\n# Being true for dangling symbolic links is also useful.\n\ndef lexists(path):\n    \"\"\"Test whether a path exists.  Returns True for broken symbolic links\"\"\"\n    try:\n        os.lstat(path)\n    except (OSError, ValueError):\n        return False\n    return True\n\n\n# Is a path a mount point?\n# (Does this work for all UNIXes?  Is it even guaranteed to work by Posix?)\n\ndef ismount(path):\n    \"\"\"Test whether a path is a mount point\"\"\"\n    try:\n        s1 = os.lstat(path)\n    except (OSError, ValueError):\n        # It doesn't exist -- so not a mount point. :-)\n        return False\n    else:\n        # A symlink can never be a mount point\n        if stat.S_ISLNK(s1.st_mode):\n            return False\n\n    if isinstance(path, bytes):\n        parent = join(path, b'..')\n    else:\n        parent = join(path, '..')\n    parent = realpath(parent)\n    try:\n        s2 = os.lstat(parent)\n    except (OSError, ValueError):\n        return False\n\n    dev1 = s1.st_dev\n    dev2 = s2.st_dev\n    if dev1 != dev2:\n        return True     # path/.. on a different device as path\n    ino1 = s1.st_ino\n    ino2 = s2.st_ino\n    if ino1 == ino2:\n        return True     # path/.. is the same i-node as path\n    return False\n\n\n# Expand paths beginning with '~' or '~user'.\n# '~' means $HOME; '~user' means that user's home directory.\n# If the path doesn't begin with '~', or if the user or $HOME is unknown,\n# the path is returned unchanged (leaving error reporting to whatever\n# function is called with the expanded path as argument).\n# See also module 'glob' for expansion of *, ? and [...] in pathnames.\n# (A function should also be defined to do full *sh-style environment\n# variable expansion.)\n\ndef expanduser(path):\n    \"\"\"Expand ~ and ~user constructions.  If user or $HOME is unknown,\n    do nothing.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        tilde = b'~'\n    else:\n        tilde = '~'\n    if not path.startswith(tilde):\n        return path\n    sep = _get_sep(path)\n    i = path.find(sep, 1)\n    if i < 0:\n        i = len(path)\n    if i == 1:\n        if 'HOME' not in os.environ:\n            import pwd\n            try:\n                userhome = pwd.getpwuid(os.getuid()).pw_dir\n            except KeyError:\n                # bpo-10496: if the current user identifier doesn't exist in the\n                # password database, return the path unchanged\n                return path\n        else:\n            userhome = os.environ['HOME']\n    else:\n        import pwd\n        name = path[1:i]\n        if isinstance(name, bytes):\n            name = str(name, 'ASCII')\n        try:\n            pwent = pwd.getpwnam(name)\n        except KeyError:\n            # bpo-10496: if the user name from the path doesn't exist in the\n            # password database, return the path unchanged\n            return path\n        userhome = pwent.pw_dir\n    if isinstance(path, bytes):\n        userhome = os.fsencode(userhome)\n        root = b'/'\n    else:\n        root = '/'\n    userhome = userhome.rstrip(root)\n    return (userhome + path[i:]) or root\n\n\n# Expand paths containing shell variable substitutions.\n# This expands the forms $variable and ${variable} only.\n# Non-existent variables are left unchanged.\n\n_varprog = None\n_varprogb = None\n\ndef expandvars(path):\n    \"\"\"Expand shell variables of form $var and ${var}.  Unknown variables\n    are left unchanged.\"\"\"\n    path = os.fspath(path)\n    global _varprog, _varprogb\n    if isinstance(path, bytes):\n        if b'$' not in path:\n            return path\n        if not _varprogb:\n            import re\n            _varprogb = re.compile(br'\\$(\\w+|\\{[^}]*\\})', re.ASCII)\n        search = _varprogb.search\n        start = b'{'\n        end = b'}'\n        environ = getattr(os, 'environb', None)\n    else:\n        if '$' not in path:\n            return path\n        if not _varprog:\n            import re\n            _varprog = re.compile(r'\\$(\\w+|\\{[^}]*\\})', re.ASCII)\n        search = _varprog.search\n        start = '{'\n        end = '}'\n        environ = os.environ\n    i = 0\n    while True:\n        m = search(path, i)\n        if not m:\n            break\n        i, j = m.span(0)\n        name = m.group(1)\n        if name.startswith(start) and name.endswith(end):\n            name = name[1:-1]\n        try:\n            if environ is None:\n                value = os.fsencode(os.environ[os.fsdecode(name)])\n            else:\n                value = environ[name]\n        except KeyError:\n            i = j\n        else:\n            tail = path[j:]\n            path = path[:i] + value\n            i = len(path)\n            path += tail\n    return path\n\n\n# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.\n# It should be understood that this may change the meaning of the path\n# if it contains symbolic links!\n\ndef normpath(path):\n    \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'/'\n        empty = b''\n        dot = b'.'\n        dotdot = b'..'\n    else:\n        sep = '/'\n        empty = ''\n        dot = '.'\n        dotdot = '..'\n    if path == empty:\n        return dot\n    initial_slashes = path.startswith(sep)\n    # POSIX allows one or two initial slashes, but treats three or more\n    # as single slash.\n    if (initial_slashes and\n        path.startswith(sep*2) and not path.startswith(sep*3)):\n        initial_slashes = 2\n    comps = path.split(sep)\n    new_comps = []\n    for comp in comps:\n        if comp in (empty, dot):\n            continue\n        if (comp != dotdot or (not initial_slashes and not new_comps) or\n             (new_comps and new_comps[-1] == dotdot)):\n            new_comps.append(comp)\n        elif new_comps:\n            new_comps.pop()\n    comps = new_comps\n    path = sep.join(comps)\n    if initial_slashes:\n        path = sep*initial_slashes + path\n    return path or dot\n\n\ndef abspath(path):\n    \"\"\"Return an absolute path.\"\"\"\n    path = os.fspath(path)\n    if not isabs(path):\n        if isinstance(path, bytes):\n            cwd = os.getcwdb()\n        else:\n            cwd = os.getcwd()\n        path = join(cwd, path)\n    return normpath(path)\n\n\n# Return a canonical path (i.e. the absolute location of a file on the\n# filesystem).\n\ndef realpath(filename):\n    \"\"\"Return the canonical path of the specified filename, eliminating any\nsymbolic links encountered in the path.\"\"\"\n    filename = os.fspath(filename)\n    path, ok = _joinrealpath(filename[:0], filename, {})\n    return abspath(path)\n\n# Join two paths, normalizing and eliminating any symbolic links\n# encountered in the second path.\ndef _joinrealpath(path, rest, seen):\n    if isinstance(path, bytes):\n        sep = b'/'\n        curdir = b'.'\n        pardir = b'..'\n    else:\n        sep = '/'\n        curdir = '.'\n        pardir = '..'\n\n    if isabs(rest):\n        rest = rest[1:]\n        path = sep\n\n    while rest:\n        name, _, rest = rest.partition(sep)\n        if not name or name == curdir:\n            # current dir\n            continue\n        if name == pardir:\n            # parent dir\n            if path:\n                path, name = split(path)\n                if name == pardir:\n                    path = join(path, pardir, pardir)\n            else:\n                path = pardir\n            continue\n        newpath = join(path, name)\n        if not islink(newpath):\n            path = newpath\n            continue\n        # Resolve the symbolic link\n        if newpath in seen:\n            # Already seen this path\n            path = seen[newpath]\n            if path is not None:\n                # use cached value\n                continue\n            # The symlink is not resolved, so we must have a symlink loop.\n            # Return already resolved part + rest of the path unchanged.\n            return join(newpath, rest), False\n        seen[newpath] = None # not resolved symlink\n        path, ok = _joinrealpath(path, os.readlink(newpath), seen)\n        if not ok:\n            return join(path, rest), False\n        seen[newpath] = path # resolved symlink\n\n    return path, True\n\n\nsupports_unicode_filenames = (sys.platform == 'darwin')\n\ndef relpath(path, start=None):\n    \"\"\"Return a relative version of a path\"\"\"\n\n    if not path:\n        raise ValueError(\"no path specified\")\n\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        curdir = b'.'\n        sep = b'/'\n        pardir = b'..'\n    else:\n        curdir = '.'\n        sep = '/'\n        pardir = '..'\n\n    if start is None:\n        start = curdir\n    else:\n        start = os.fspath(start)\n\n    try:\n        start_list = [x for x in abspath(start).split(sep) if x]\n        path_list = [x for x in abspath(path).split(sep) if x]\n        # Work out how much of the filepath is shared by start and path.\n        i = len(commonprefix([start_list, path_list]))\n\n        rel_list = [pardir] * (len(start_list)-i) + path_list[i:]\n        if not rel_list:\n            return curdir\n        return join(*rel_list)\n    except (TypeError, AttributeError, BytesWarning, DeprecationWarning):\n        genericpath._check_arg_types('relpath', path, start)\n        raise\n\n\n# Return the longest common sub-path of the sequence of paths given as input.\n# The paths are not normalized before comparing them (this is the\n# responsibility of the caller). Any trailing separator is stripped from the\n# returned path.\n\ndef commonpath(paths):\n    \"\"\"Given a sequence of path names, returns the longest common sub-path.\"\"\"\n\n    if not paths:\n        raise ValueError('commonpath() arg is an empty sequence')\n\n    paths = tuple(map(os.fspath, paths))\n    if isinstance(paths[0], bytes):\n        sep = b'/'\n        curdir = b'.'\n    else:\n        sep = '/'\n        curdir = '.'\n\n    try:\n        split_paths = [path.split(sep) for path in paths]\n\n        try:\n            isabs, = set(p[:1] == sep for p in paths)\n        except ValueError:\n            raise ValueError(\"Can't mix absolute and relative paths\") from None\n\n        split_paths = [[c for c in s if c and c != curdir] for s in split_paths]\n        s1 = min(split_paths)\n        s2 = max(split_paths)\n        common = s1\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                common = s1[:i]\n                break\n\n        prefix = sep if isabs else sep[:0]\n        return prefix + sep.join(common)\n    except (TypeError, AttributeError):\n        genericpath._check_arg_types('commonpath', *paths)\n        raise\n", 525], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py": ["# Copyright 2007 Google, Inc. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nUnit tests are in test_collections.\n\"\"\"\n\nfrom abc import ABCMeta, abstractmethod\nimport sys\n\n__all__ = [\"Awaitable\", \"Coroutine\",\n           \"AsyncIterable\", \"AsyncIterator\", \"AsyncGenerator\",\n           \"Hashable\", \"Iterable\", \"Iterator\", \"Generator\", \"Reversible\",\n           \"Sized\", \"Container\", \"Callable\", \"Collection\",\n           \"Set\", \"MutableSet\",\n           \"Mapping\", \"MutableMapping\",\n           \"MappingView\", \"KeysView\", \"ItemsView\", \"ValuesView\",\n           \"Sequence\", \"MutableSequence\",\n           \"ByteString\",\n           ]\n\n# This module has been renamed from collections.abc to _collections_abc to\n# speed up interpreter startup. Some of the types such as MutableMapping are\n# required early but collections module imports a lot of other modules.\n# See issue #19218\n__name__ = \"collections.abc\"\n\n# Private list of types that we want to register with the various ABCs\n# so that they will pass tests like:\n#       it = iter(somebytearray)\n#       assert isinstance(it, Iterable)\n# Note:  in other implementations, these types might not be distinct\n# and they may have their own implementation specific types that\n# are not included on this list.\nbytes_iterator = type(iter(b''))\nbytearray_iterator = type(iter(bytearray()))\n#callable_iterator = ???\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nlongrange_iterator = type(iter(range(1 << 1000)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\nmappingproxy = type(type.__dict__)\ngenerator = type((lambda: (yield))())\n## coroutine ##\nasync def _coro(): pass\n_coro = _coro()\ncoroutine = type(_coro)\n_coro.close()  # Prevent ResourceWarning\ndel _coro\n## asynchronous generator ##\nasync def _ag(): yield\n_ag = _ag()\nasync_generator = type(_ag)\ndel _ag\n\n\n### ONE-TRICK PONIES ###\n\ndef _check_methods(C, *methods):\n    mro = C.__mro__\n    for method in methods:\n        for B in mro:\n            if method in B.__dict__:\n                if B.__dict__[method] is None:\n                    return NotImplemented\n                break\n        else:\n            return NotImplemented\n    return True\n\nclass Hashable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __hash__(self):\n        return 0\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Hashable:\n            return _check_methods(C, \"__hash__\")\n        return NotImplemented\n\n\nclass Awaitable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __await__(self):\n        yield\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Awaitable:\n            return _check_methods(C, \"__await__\")\n        return NotImplemented\n\n\nclass Coroutine(Awaitable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def send(self, value):\n        \"\"\"Send a value into the coroutine.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        raise StopIteration\n\n    @abstractmethod\n    def throw(self, typ, val=None, tb=None):\n        \"\"\"Raise an exception in the coroutine.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        if val is None:\n            if tb is None:\n                raise typ\n            val = typ()\n        if tb is not None:\n            val = val.with_traceback(tb)\n        raise val\n\n    def close(self):\n        \"\"\"Raise GeneratorExit inside coroutine.\n        \"\"\"\n        try:\n            self.throw(GeneratorExit)\n        except (GeneratorExit, StopIteration):\n            pass\n        else:\n            raise RuntimeError(\"coroutine ignored GeneratorExit\")\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Coroutine:\n            return _check_methods(C, '__await__', 'send', 'throw', 'close')\n        return NotImplemented\n\n\nCoroutine.register(coroutine)\n\n\nclass AsyncIterable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __aiter__(self):\n        return AsyncIterator()\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncIterable:\n            return _check_methods(C, \"__aiter__\")\n        return NotImplemented\n\n\nclass AsyncIterator(AsyncIterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    async def __anext__(self):\n        \"\"\"Return the next item or raise StopAsyncIteration when exhausted.\"\"\"\n        raise StopAsyncIteration\n\n    def __aiter__(self):\n        return self\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncIterator:\n            return _check_methods(C, \"__anext__\", \"__aiter__\")\n        return NotImplemented\n\n\nclass AsyncGenerator(AsyncIterator):\n\n    __slots__ = ()\n\n    async def __anext__(self):\n        \"\"\"Return the next item from the asynchronous generator.\n        When exhausted, raise StopAsyncIteration.\n        \"\"\"\n        return await self.asend(None)\n\n    @abstractmethod\n    async def asend(self, value):\n        \"\"\"Send a value into the asynchronous generator.\n        Return next yielded value or raise StopAsyncIteration.\n        \"\"\"\n        raise StopAsyncIteration\n\n    @abstractmethod\n    async def athrow(self, typ, val=None, tb=None):\n        \"\"\"Raise an exception in the asynchronous generator.\n        Return next yielded value or raise StopAsyncIteration.\n        \"\"\"\n        if val is None:\n            if tb is None:\n                raise typ\n            val = typ()\n        if tb is not None:\n            val = val.with_traceback(tb)\n        raise val\n\n    async def aclose(self):\n        \"\"\"Raise GeneratorExit inside coroutine.\n        \"\"\"\n        try:\n            await self.athrow(GeneratorExit)\n        except (GeneratorExit, StopAsyncIteration):\n            pass\n        else:\n            raise RuntimeError(\"asynchronous generator ignored GeneratorExit\")\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncGenerator:\n            return _check_methods(C, '__aiter__', '__anext__',\n                                  'asend', 'athrow', 'aclose')\n        return NotImplemented\n\n\nAsyncGenerator.register(async_generator)\n\n\nclass Iterable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __iter__(self):\n        while False:\n            yield None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterable:\n            return _check_methods(C, \"__iter__\")\n        return NotImplemented\n\n\nclass Iterator(Iterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __next__(self):\n        'Return the next item from the iterator. When exhausted, raise StopIteration'\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterator:\n            return _check_methods(C, '__iter__', '__next__')\n        return NotImplemented\n\nIterator.register(bytes_iterator)\nIterator.register(bytearray_iterator)\n#Iterator.register(callable_iterator)\nIterator.register(dict_keyiterator)\nIterator.register(dict_valueiterator)\nIterator.register(dict_itemiterator)\nIterator.register(list_iterator)\nIterator.register(list_reverseiterator)\nIterator.register(range_iterator)\nIterator.register(longrange_iterator)\nIterator.register(set_iterator)\nIterator.register(str_iterator)\nIterator.register(tuple_iterator)\nIterator.register(zip_iterator)\n\n\nclass Reversible(Iterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __reversed__(self):\n        while False:\n            yield None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Reversible:\n            return _check_methods(C, \"__reversed__\", \"__iter__\")\n        return NotImplemented\n\n\nclass Generator(Iterator):\n\n    __slots__ = ()\n\n    def __next__(self):\n        \"\"\"Return the next item from the generator.\n        When exhausted, raise StopIteration.\n        \"\"\"\n        return self.send(None)\n\n    @abstractmethod\n    def send(self, value):\n        \"\"\"Send a value into the generator.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        raise StopIteration\n\n    @abstractmethod\n    def throw(self, typ, val=None, tb=None):\n        \"\"\"Raise an exception in the generator.\n        Return next yielded value or raise StopIteration.\n        \"\"\"\n        if val is None:\n            if tb is None:\n                raise typ\n            val = typ()\n        if tb is not None:\n            val = val.with_traceback(tb)\n        raise val\n\n    def close(self):\n        \"\"\"Raise GeneratorExit inside generator.\n        \"\"\"\n        try:\n            self.throw(GeneratorExit)\n        except (GeneratorExit, StopIteration):\n            pass\n        else:\n            raise RuntimeError(\"generator ignored GeneratorExit\")\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Generator:\n            return _check_methods(C, '__iter__', '__next__',\n                                  'send', 'throw', 'close')\n        return NotImplemented\n\nGenerator.register(generator)\n\n\nclass Sized(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __len__(self):\n        return 0\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Sized:\n            return _check_methods(C, \"__len__\")\n        return NotImplemented\n\n\nclass Container(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __contains__(self, x):\n        return False\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Container:\n            return _check_methods(C, \"__contains__\")\n        return NotImplemented\n\nclass Collection(Sized, Iterable, Container):\n\n    __slots__ = ()\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Collection:\n            return _check_methods(C,  \"__len__\", \"__iter__\", \"__contains__\")\n        return NotImplemented\n\nclass Callable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __call__(self, *args, **kwds):\n        return False\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Callable:\n            return _check_methods(C, \"__call__\")\n        return NotImplemented\n\n\n### SETS ###\n\n\nclass Set(Collection):\n\n    \"\"\"A set is a finite, iterable container.\n\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__ and __len__.\n\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), redefine __le__ and __ge__,\n    then the other operations will automatically follow suit.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __le__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(self) > len(other):\n            return False\n        for elem in self:\n            if elem not in other:\n                return False\n        return True\n\n    def __lt__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(self) < len(other) and self.__le__(other)\n\n    def __gt__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(self) > len(other) and self.__ge__(other)\n\n    def __ge__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(self) < len(other):\n            return False\n        for elem in other:\n            if elem not in self:\n                return False\n        return True\n\n    def __eq__(self, other):\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(self) == len(other) and self.__le__(other)\n\n    @classmethod\n    def _from_iterable(cls, it):\n        '''Construct an instance of the class from any iterable input.\n\n        Must override this method if the class constructor signature\n        does not accept an iterable for an input.\n        '''\n        return cls(it)\n\n    def __and__(self, other):\n        if not isinstance(other, Iterable):\n            return NotImplemented\n        return self._from_iterable(value for value in other if value in self)\n\n    __rand__ = __and__\n\n    def isdisjoint(self, other):\n        'Return True if two sets have a null intersection.'\n        for value in other:\n            if value in self:\n                return False\n        return True\n\n    def __or__(self, other):\n        if not isinstance(other, Iterable):\n            return NotImplemented\n        chain = (e for s in (self, other) for e in s)\n        return self._from_iterable(chain)\n\n    __ror__ = __or__\n\n    def __sub__(self, other):\n        if not isinstance(other, Set):\n            if not isinstance(other, Iterable):\n                return NotImplemented\n            other = self._from_iterable(other)\n        return self._from_iterable(value for value in self\n                                   if value not in other)\n\n    def __rsub__(self, other):\n        if not isinstance(other, Set):\n            if not isinstance(other, Iterable):\n                return NotImplemented\n            other = self._from_iterable(other)\n        return self._from_iterable(value for value in other\n                                   if value not in self)\n\n    def __xor__(self, other):\n        if not isinstance(other, Set):\n            if not isinstance(other, Iterable):\n                return NotImplemented\n            other = self._from_iterable(other)\n        return (self - other) | (other - self)\n\n    __rxor__ = __xor__\n\n    def _hash(self):\n        \"\"\"Compute the hash value of a set.\n\n        Note that we don't define __hash__: not all sets are hashable.\n        But if you define a hashable set type, its __hash__ should\n        call this function.\n\n        This must be compatible __eq__.\n\n        All sets ought to compare equal if they contain the same\n        elements, regardless of how they are implemented, and\n        regardless of the order of the elements; so there's not much\n        freedom for __eq__ or __hash__.  We match the algorithm used\n        by the built-in frozenset type.\n        \"\"\"\n        MAX = sys.maxsize\n        MASK = 2 * MAX + 1\n        n = len(self)\n        h = 1927868237 * (n + 1)\n        h &= MASK\n        for x in self:\n            hx = hash(x)\n            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167\n            h &= MASK\n        h = h * 69069 + 907133923\n        h &= MASK\n        if h > MAX:\n            h -= MASK + 1\n        if h == -1:\n            h = 590923713\n        return h\n\nSet.register(frozenset)\n\n\nclass MutableSet(Set):\n    \"\"\"A mutable set is a finite, iterable container.\n\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__, __len__,\n    add(), and discard().\n\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), all you have to do is redefine __le__ and\n    then the other operations will automatically follow suit.\n    \"\"\"\n\n    __slots__ = ()\n\n    @abstractmethod\n    def add(self, value):\n        \"\"\"Add an element.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def discard(self, value):\n        \"\"\"Remove an element.  Do not raise an exception if absent.\"\"\"\n        raise NotImplementedError\n\n    def remove(self, value):\n        \"\"\"Remove an element. If not a member, raise a KeyError.\"\"\"\n        if value not in self:\n            raise KeyError(value)\n        self.discard(value)\n\n    def pop(self):\n        \"\"\"Return the popped value.  Raise KeyError if empty.\"\"\"\n        it = iter(self)\n        try:\n            value = next(it)\n        except StopIteration:\n            raise KeyError from None\n        self.discard(value)\n        return value\n\n    def clear(self):\n        \"\"\"This is slow (creates N new iterators!) but effective.\"\"\"\n        try:\n            while True:\n                self.pop()\n        except KeyError:\n            pass\n\n    def __ior__(self, it):\n        for value in it:\n            self.add(value)\n        return self\n\n    def __iand__(self, it):\n        for value in (self - it):\n            self.discard(value)\n        return self\n\n    def __ixor__(self, it):\n        if it is self:\n            self.clear()\n        else:\n            if not isinstance(it, Set):\n                it = self._from_iterable(it)\n            for value in it:\n                if value in self:\n                    self.discard(value)\n                else:\n                    self.add(value)\n        return self\n\n    def __isub__(self, it):\n        if it is self:\n            self.clear()\n        else:\n            for value in it:\n                self.discard(value)\n        return self\n\nMutableSet.register(set)\n\n\n### MAPPINGS ###\n\n\nclass Mapping(Collection):\n\n    __slots__ = ()\n\n    \"\"\"A Mapping is a generic container for associating key/value\n    pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __iter__, and __len__.\n\n    \"\"\"\n\n    @abstractmethod\n    def __getitem__(self, key):\n        raise KeyError\n\n    def get(self, key, default=None):\n        'D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.'\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __contains__(self, key):\n        try:\n            self[key]\n        except KeyError:\n            return False\n        else:\n            return True\n\n    def keys(self):\n        \"D.keys() -> a set-like object providing a view on D's keys\"\n        return KeysView(self)\n\n    def items(self):\n        \"D.items() -> a set-like object providing a view on D's items\"\n        return ItemsView(self)\n\n    def values(self):\n        \"D.values() -> an object providing a view on D's values\"\n        return ValuesView(self)\n\n    def __eq__(self, other):\n        if not isinstance(other, Mapping):\n            return NotImplemented\n        return dict(self.items()) == dict(other.items())\n\n    __reversed__ = None\n\nMapping.register(mappingproxy)\n\n\nclass MappingView(Sized):\n\n    __slots__ = '_mapping',\n\n    def __init__(self, mapping):\n        self._mapping = mapping\n\n    def __len__(self):\n        return len(self._mapping)\n\n    def __repr__(self):\n        return '{0.__class__.__name__}({0._mapping!r})'.format(self)\n\n\nclass KeysView(MappingView, Set):\n\n    __slots__ = ()\n\n    @classmethod\n    def _from_iterable(self, it):\n        return set(it)\n\n    def __contains__(self, key):\n        return key in self._mapping\n\n    def __iter__(self):\n        yield from self._mapping\n\nKeysView.register(dict_keys)\n\n\nclass ItemsView(MappingView, Set):\n\n    __slots__ = ()\n\n    @classmethod\n    def _from_iterable(self, it):\n        return set(it)\n\n    def __contains__(self, item):\n        key, value = item\n        try:\n            v = self._mapping[key]\n        except KeyError:\n            return False\n        else:\n            return v is value or v == value\n\n    def __iter__(self):\n        for key in self._mapping:\n            yield (key, self._mapping[key])\n\nItemsView.register(dict_items)\n\n\nclass ValuesView(MappingView, Collection):\n\n    __slots__ = ()\n\n    def __contains__(self, value):\n        for key in self._mapping:\n            v = self._mapping[key]\n            if v is value or v == value:\n                return True\n        return False\n\n    def __iter__(self):\n        for key in self._mapping:\n            yield self._mapping[key]\n\nValuesView.register(dict_values)\n\n\nclass MutableMapping(Mapping):\n\n    __slots__ = ()\n\n    \"\"\"A MutableMapping is a generic container for associating\n    key/value pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __setitem__, __delitem__,\n    __iter__, and __len__.\n\n    \"\"\"\n\n    @abstractmethod\n    def __setitem__(self, key, value):\n        raise KeyError\n\n    @abstractmethod\n    def __delitem__(self, key):\n        raise KeyError\n\n    __marker = object()\n\n    def pop(self, key, default=__marker):\n        '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n          If key is not found, d is returned if given, otherwise KeyError is raised.\n        '''\n        try:\n            value = self[key]\n        except KeyError:\n            if default is self.__marker:\n                raise\n            return default\n        else:\n            del self[key]\n            return value\n\n    def popitem(self):\n        '''D.popitem() -> (k, v), remove and return some (key, value) pair\n           as a 2-tuple; but raise KeyError if D is empty.\n        '''\n        try:\n            key = next(iter(self))\n        except StopIteration:\n            raise KeyError from None\n        value = self[key]\n        del self[key]\n        return key, value\n\n    def clear(self):\n        'D.clear() -> None.  Remove all items from D.'\n        try:\n            while True:\n                self.popitem()\n        except KeyError:\n            pass\n\n    def update(self, other=(), /, **kwds):\n        ''' D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n            If E present and has a .keys() method, does:     for k in E: D[k] = E[k]\n            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n            In either case, this is followed by: for k, v in F.items(): D[k] = v\n        '''\n        if isinstance(other, Mapping):\n            for key in other:\n                self[key] = other[key]\n        elif hasattr(other, \"keys\"):\n            for key in other.keys():\n                self[key] = other[key]\n        else:\n            for key, value in other:\n                self[key] = value\n        for key, value in kwds.items():\n            self[key] = value\n\n    def setdefault(self, key, default=None):\n        'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D'\n        try:\n            return self[key]\n        except KeyError:\n            self[key] = default\n        return default\n\nMutableMapping.register(dict)\n\n\n### SEQUENCES ###\n\n\nclass Sequence(Reversible, Collection):\n\n    \"\"\"All the operations on a read-only sequence.\n\n    Concrete subclasses must override __new__ or __init__,\n    __getitem__, and __len__.\n    \"\"\"\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __getitem__(self, index):\n        raise IndexError\n\n    def __iter__(self):\n        i = 0\n        try:\n            while True:\n                v = self[i]\n                yield v\n                i += 1\n        except IndexError:\n            return\n\n    def __contains__(self, value):\n        for v in self:\n            if v is value or v == value:\n                return True\n        return False\n\n    def __reversed__(self):\n        for i in reversed(range(len(self))):\n            yield self[i]\n\n    def index(self, value, start=0, stop=None):\n        '''S.index(value, [start, [stop]]) -> integer -- return first index of value.\n           Raises ValueError if the value is not present.\n\n           Supporting start and stop arguments is optional, but\n           recommended.\n        '''\n        if start is not None and start < 0:\n            start = max(len(self) + start, 0)\n        if stop is not None and stop < 0:\n            stop += len(self)\n\n        i = start\n        while stop is None or i < stop:\n            try:\n                v = self[i]\n                if v is value or v == value:\n                    return i\n            except IndexError:\n                break\n            i += 1\n        raise ValueError\n\n    def count(self, value):\n        'S.count(value) -> integer -- return number of occurrences of value'\n        return sum(1 for v in self if v is value or v == value)\n\nSequence.register(tuple)\nSequence.register(str)\nSequence.register(range)\nSequence.register(memoryview)\n\n\nclass ByteString(Sequence):\n\n    \"\"\"This unifies bytes and bytearray.\n\n    XXX Should add all their methods.\n    \"\"\"\n\n    __slots__ = ()\n\nByteString.register(bytes)\nByteString.register(bytearray)\n\n\nclass MutableSequence(Sequence):\n\n    __slots__ = ()\n\n    \"\"\"All the operations on a read-write sequence.\n\n    Concrete subclasses must provide __new__ or __init__,\n    __getitem__, __setitem__, __delitem__, __len__, and insert().\n\n    \"\"\"\n\n    @abstractmethod\n    def __setitem__(self, index, value):\n        raise IndexError\n\n    @abstractmethod\n    def __delitem__(self, index):\n        raise IndexError\n\n    @abstractmethod\n    def insert(self, index, value):\n        'S.insert(index, value) -- insert value before index'\n        raise IndexError\n\n    def append(self, value):\n        'S.append(value) -- append value to the end of the sequence'\n        self.insert(len(self), value)\n\n    def clear(self):\n        'S.clear() -> None -- remove all items from S'\n        try:\n            while True:\n                self.pop()\n        except IndexError:\n            pass\n\n    def reverse(self):\n        'S.reverse() -- reverse *IN PLACE*'\n        n = len(self)\n        for i in range(n//2):\n            self[i], self[n-i-1] = self[n-i-1], self[i]\n\n    def extend(self, values):\n        'S.extend(iterable) -- extend sequence by appending elements from the iterable'\n        if values is self:\n            values = list(values)\n        for v in values:\n            self.append(v)\n\n    def pop(self, index=-1):\n        '''S.pop([index]) -> item -- remove and return item at index (default last).\n           Raise IndexError if list is empty or index is out of range.\n        '''\n        v = self[index]\n        del self[index]\n        return v\n\n    def remove(self, value):\n        '''S.remove(value) -- remove first occurrence of value.\n           Raise ValueError if the value is not present.\n        '''\n        del self[self.index(value)]\n\n    def __iadd__(self, values):\n        self.extend(values)\n        return self\n\nMutableSequence.register(list)\nMutableSequence.register(bytearray)  # Multiply inheriting, see ByteString\n", 1004], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py": ["# Copyright 2007 Google, Inc. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\n\ndef abstractmethod(funcobj):\n    \"\"\"A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, ...):\n                ...\n    \"\"\"\n    funcobj.__isabstractmethod__ = True\n    return funcobj\n\n\nclass abstractclassmethod(classmethod):\n    \"\"\"A decorator indicating abstract classmethods.\n\n    Deprecated, use 'classmethod' with 'abstractmethod' instead.\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractstaticmethod(staticmethod):\n    \"\"\"A decorator indicating abstract staticmethods.\n\n    Deprecated, use 'staticmethod' with 'abstractmethod' instead.\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractproperty(property):\n    \"\"\"A decorator indicating abstract properties.\n\n    Deprecated, use 'property' with 'abstractmethod' instead.\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n\ntry:\n    from _abc import (get_cache_token, _abc_init, _abc_register,\n                      _abc_instancecheck, _abc_subclasscheck, _get_dump,\n                      _reset_registry, _reset_caches)\nexcept ImportError:\n    from _py_abc import ABCMeta, get_cache_token\n    ABCMeta.__module__ = 'abc'\nelse:\n    class ABCMeta(type):\n        \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n\n        Use this metaclass to create an ABC.  An ABC can be subclassed\n        directly, and then acts as a mix-in class.  You can also register\n        unrelated concrete classes (even built-in classes) and unrelated\n        ABCs as 'virtual subclasses' -- these and their descendants will\n        be considered subclasses of the registering ABC by the built-in\n        issubclass() function, but the registering ABC won't show up in\n        their MRO (Method Resolution Order) nor will method\n        implementations defined by the registering ABC be callable (not\n        even via super()).\n        \"\"\"\n        def __new__(mcls, name, bases, namespace, **kwargs):\n            cls = super().__new__(mcls, name, bases, namespace, **kwargs)\n            _abc_init(cls)\n            return cls\n\n        def register(cls, subclass):\n            \"\"\"Register a virtual subclass of an ABC.\n\n            Returns the subclass, to allow usage as a class decorator.\n            \"\"\"\n            return _abc_register(cls, subclass)\n\n        def __instancecheck__(cls, instance):\n            \"\"\"Override for isinstance(instance, cls).\"\"\"\n            return _abc_instancecheck(cls, instance)\n\n        def __subclasscheck__(cls, subclass):\n            \"\"\"Override for issubclass(subclass, cls).\"\"\"\n            return _abc_subclasscheck(cls, subclass)\n\n        def _dump_registry(cls, file=None):\n            \"\"\"Debug helper to print the ABC registry.\"\"\"\n            print(f\"Class: {cls.__module__}.{cls.__qualname__}\", file=file)\n            print(f\"Inv. counter: {get_cache_token()}\", file=file)\n            (_abc_registry, _abc_cache, _abc_negative_cache,\n             _abc_negative_cache_version) = _get_dump(cls)\n            print(f\"_abc_registry: {_abc_registry!r}\", file=file)\n            print(f\"_abc_cache: {_abc_cache!r}\", file=file)\n            print(f\"_abc_negative_cache: {_abc_negative_cache!r}\", file=file)\n            print(f\"_abc_negative_cache_version: {_abc_negative_cache_version!r}\",\n                  file=file)\n\n        def _abc_registry_clear(cls):\n            \"\"\"Clear the registry (for debugging or testing).\"\"\"\n            _reset_registry(cls)\n\n        def _abc_caches_clear(cls):\n            \"\"\"Clear the caches (for debugging or testing).\"\"\"\n            _reset_caches(cls)\n\n\nclass ABC(metaclass=ABCMeta):\n    \"\"\"Helper class that provides a standard way to create an ABC using\n    inheritance.\n    \"\"\"\n    __slots__ = ()\n", 129], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py": ["\"\"\"\nPath operations common to more than one OS\nDo not use directly.  The OS specific modules import the appropriate\nfunctions from this module themselves.\n\"\"\"\nimport os\nimport stat\n\n__all__ = ['commonprefix', 'exists', 'getatime', 'getctime', 'getmtime',\n           'getsize', 'isdir', 'isfile', 'samefile', 'sameopenfile',\n           'samestat']\n\n\n# Does a path exist?\n# This is false for dangling symbolic links on systems that support them.\ndef exists(path):\n    \"\"\"Test whether a path exists.  Returns False for broken symbolic links\"\"\"\n    try:\n        os.stat(path)\n    except (OSError, ValueError):\n        return False\n    return True\n\n\n# This follows symbolic links, so both islink() and isdir() can be true\n# for the same path on systems that support symlinks\ndef isfile(path):\n    \"\"\"Test whether a path is a regular file\"\"\"\n    try:\n        st = os.stat(path)\n    except (OSError, ValueError):\n        return False\n    return stat.S_ISREG(st.st_mode)\n\n\n# Is a path a directory?\n# This follows symbolic links, so both islink() and isdir()\n# can be true for the same path on systems that support symlinks\ndef isdir(s):\n    \"\"\"Return true if the pathname refers to an existing directory.\"\"\"\n    try:\n        st = os.stat(s)\n    except (OSError, ValueError):\n        return False\n    return stat.S_ISDIR(st.st_mode)\n\n\ndef getsize(filename):\n    \"\"\"Return the size of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_size\n\n\ndef getmtime(filename):\n    \"\"\"Return the last modification time of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_mtime\n\n\ndef getatime(filename):\n    \"\"\"Return the last access time of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_atime\n\n\ndef getctime(filename):\n    \"\"\"Return the metadata change time of a file, reported by os.stat().\"\"\"\n    return os.stat(filename).st_ctime\n\n\n# Return the longest prefix of all list elements.\ndef commonprefix(m):\n    \"Given a list of pathnames, returns the longest common leading component\"\n    if not m: return ''\n    # Some people pass in a list of pathname parts to operate in an OS-agnostic\n    # fashion; don't try to translate in that case as that's an abuse of the\n    # API and they are already doing what they need to be OS-agnostic and so\n    # they most likely won't be using an os.PathLike object in the sublists.\n    if not isinstance(m[0], (list, tuple)):\n        m = tuple(map(os.fspath, m))\n    s1 = min(m)\n    s2 = max(m)\n    for i, c in enumerate(s1):\n        if c != s2[i]:\n            return s1[:i]\n    return s1\n\n# Are two stat buffers (obtained from stat, fstat or lstat)\n# describing the same file?\ndef samestat(s1, s2):\n    \"\"\"Test whether two stat buffers reference the same file\"\"\"\n    return (s1.st_ino == s2.st_ino and\n            s1.st_dev == s2.st_dev)\n\n\n# Are two filenames really pointing to the same file?\ndef samefile(f1, f2):\n    \"\"\"Test whether two pathnames reference the same actual file or directory\n\n    This is determined by the device number and i-node number and\n    raises an exception if an os.stat() call on either pathname fails.\n    \"\"\"\n    s1 = os.stat(f1)\n    s2 = os.stat(f2)\n    return samestat(s1, s2)\n\n\n# Are two open files really referencing the same file?\n# (Not necessarily the same file descriptor!)\ndef sameopenfile(fp1, fp2):\n    \"\"\"Test whether two open file objects reference the same file\"\"\"\n    s1 = os.fstat(fp1)\n    s2 = os.fstat(fp2)\n    return samestat(s1, s2)\n\n\n# Split a path in root and extension.\n# The extension is everything starting at the last dot in the last\n# pathname component; the root is everything before that.\n# It is always true that root + ext == p.\n\n# Generic implementation of splitext, to be parametrized with\n# the separators\ndef _splitext(p, sep, altsep, extsep):\n    \"\"\"Split the extension from a pathname.\n\n    Extension is everything from the last dot to the end, ignoring\n    leading dots.  Returns \"(root, ext)\"; ext may be empty.\"\"\"\n    # NOTE: This code must work for text and bytes strings.\n\n    sepIndex = p.rfind(sep)\n    if altsep:\n        altsepIndex = p.rfind(altsep)\n        sepIndex = max(sepIndex, altsepIndex)\n\n    dotIndex = p.rfind(extsep)\n    if dotIndex > sepIndex:\n        # skip all leading dots\n        filenameIndex = sepIndex + 1\n        while filenameIndex < dotIndex:\n            if p[filenameIndex:filenameIndex+1] != extsep:\n                return p[:dotIndex], p[dotIndex:]\n            filenameIndex += 1\n\n    return p, p[:0]\n\ndef _check_arg_types(funcname, *args):\n    hasstr = hasbytes = False\n    for s in args:\n        if isinstance(s, str):\n            hasstr = True\n        elif isinstance(s, bytes):\n            hasbytes = True\n        else:\n            raise TypeError(f'{funcname}() argument must be str, bytes, or '\n                            f'os.PathLike object, not {s.__class__.__name__!r}') from None\n    if hasstr and hasbytes:\n        raise TypeError(\"Can't mix strings and bytes in path components\") from None\n", 155], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py": ["#\n# Module providing the `Process` class which emulates `threading.Thread`\n#\n# multiprocessing/process.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\n__all__ = ['BaseProcess', 'current_process', 'active_children',\n           'parent_process']\n\n#\n# Imports\n#\n\nimport os\nimport sys\nimport signal\nimport itertools\nimport threading\nfrom _weakrefset import WeakSet\n\n#\n#\n#\n\ntry:\n    ORIGINAL_DIR = os.path.abspath(os.getcwd())\nexcept OSError:\n    ORIGINAL_DIR = None\n\n#\n# Public functions\n#\n\ndef current_process():\n    '''\n    Return process object representing the current process\n    '''\n    return _current_process\n\ndef active_children():\n    '''\n    Return list of process objects corresponding to live child processes\n    '''\n    _cleanup()\n    return list(_children)\n\n\ndef parent_process():\n    '''\n    Return process object representing the parent process\n    '''\n    return _parent_process\n\n#\n#\n#\n\ndef _cleanup():\n    # check for processes which have finished\n    for p in list(_children):\n        if p._popen.poll() is not None:\n            _children.discard(p)\n\n#\n# The `Process` class\n#\n\nclass BaseProcess(object):\n    '''\n    Process objects represent activity that is run in a separate process\n\n    The class is analogous to `threading.Thread`\n    '''\n    def _Popen(self):\n        raise NotImplementedError\n\n    def __init__(self, group=None, target=None, name=None, args=(), kwargs={},\n                 *, daemon=None):\n        assert group is None, 'group argument must be None for now'\n        count = next(_process_counter)\n        self._identity = _current_process._identity + (count,)\n        self._config = _current_process._config.copy()\n        self._parent_pid = os.getpid()\n        self._parent_name = _current_process.name\n        self._popen = None\n        self._closed = False\n        self._target = target\n        self._args = tuple(args)\n        self._kwargs = dict(kwargs)\n        self._name = name or type(self).__name__ + '-' + \\\n                     ':'.join(str(i) for i in self._identity)\n        if daemon is not None:\n            self.daemon = daemon\n        _dangling.add(self)\n\n    def _check_closed(self):\n        if self._closed:\n            raise ValueError(\"process object is closed\")\n\n    def run(self):\n        '''\n        Method to be run in sub-process; can be overridden in sub-class\n        '''\n        if self._target:\n            self._target(*self._args, **self._kwargs)\n\n    def start(self):\n        '''\n        Start child process\n        '''\n        self._check_closed()\n        assert self._popen is None, 'cannot start a process twice'\n        assert self._parent_pid == os.getpid(), \\\n               'can only start a process object created by current process'\n        assert not _current_process._config.get('daemon'), \\\n               'daemonic processes are not allowed to have children'\n        _cleanup()\n        self._popen = self._Popen(self)\n        self._sentinel = self._popen.sentinel\n        # Avoid a refcycle if the target function holds an indirect\n        # reference to the process object (see bpo-30775)\n        del self._target, self._args, self._kwargs\n        _children.add(self)\n\n    def terminate(self):\n        '''\n        Terminate process; sends SIGTERM signal or uses TerminateProcess()\n        '''\n        self._check_closed()\n        self._popen.terminate()\n\n    def kill(self):\n        '''\n        Terminate process; sends SIGKILL signal or uses TerminateProcess()\n        '''\n        self._check_closed()\n        self._popen.kill()\n\n    def join(self, timeout=None):\n        '''\n        Wait until child process terminates\n        '''\n        self._check_closed()\n        assert self._parent_pid == os.getpid(), 'can only join a child process'\n        assert self._popen is not None, 'can only join a started process'\n        res = self._popen.wait(timeout)\n        if res is not None:\n            _children.discard(self)\n\n    def is_alive(self):\n        '''\n        Return whether process is alive\n        '''\n        self._check_closed()\n        if self is _current_process:\n            return True\n        assert self._parent_pid == os.getpid(), 'can only test a child process'\n\n        if self._popen is None:\n            return False\n\n        returncode = self._popen.poll()\n        if returncode is None:\n            return True\n        else:\n            _children.discard(self)\n            return False\n\n    def close(self):\n        '''\n        Close the Process object.\n\n        This method releases resources held by the Process object.  It is\n        an error to call this method if the child process is still running.\n        '''\n        if self._popen is not None:\n            if self._popen.poll() is None:\n                raise ValueError(\"Cannot close a process while it is still running. \"\n                                 \"You should first call join() or terminate().\")\n            self._popen.close()\n            self._popen = None\n            del self._sentinel\n            _children.discard(self)\n        self._closed = True\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert isinstance(name, str), 'name must be a string'\n        self._name = name\n\n    @property\n    def daemon(self):\n        '''\n        Return whether process is a daemon\n        '''\n        return self._config.get('daemon', False)\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        '''\n        Set whether process is a daemon\n        '''\n        assert self._popen is None, 'process has already started'\n        self._config['daemon'] = daemonic\n\n    @property\n    def authkey(self):\n        return self._config['authkey']\n\n    @authkey.setter\n    def authkey(self, authkey):\n        '''\n        Set authorization key of process\n        '''\n        self._config['authkey'] = AuthenticationString(authkey)\n\n    @property\n    def exitcode(self):\n        '''\n        Return exit code of process or `None` if it has yet to stop\n        '''\n        self._check_closed()\n        if self._popen is None:\n            return self._popen\n        return self._popen.poll()\n\n    @property\n    def ident(self):\n        '''\n        Return identifier (PID) of process or `None` if it has yet to start\n        '''\n        self._check_closed()\n        if self is _current_process:\n            return os.getpid()\n        else:\n            return self._popen and self._popen.pid\n\n    pid = ident\n\n    @property\n    def sentinel(self):\n        '''\n        Return a file descriptor (Unix) or handle (Windows) suitable for\n        waiting for process termination.\n        '''\n        self._check_closed()\n        try:\n            return self._sentinel\n        except AttributeError:\n            raise ValueError(\"process not started\") from None\n\n    def __repr__(self):\n        exitcode = None\n        if self is _current_process:\n            status = 'started'\n        elif self._closed:\n            status = 'closed'\n        elif self._parent_pid != os.getpid():\n            status = 'unknown'\n        elif self._popen is None:\n            status = 'initial'\n        else:\n            exitcode = self._popen.poll()\n            if exitcode is not None:\n                status = 'stopped'\n            else:\n                status = 'started'\n\n        info = [type(self).__name__, 'name=%r' % self._name]\n        if self._popen is not None:\n            info.append('pid=%s' % self._popen.pid)\n        info.append('parent=%s' % self._parent_pid)\n        info.append(status)\n        if exitcode is not None:\n            exitcode = _exitcode_to_name.get(exitcode, exitcode)\n            info.append('exitcode=%s' % exitcode)\n        if self.daemon:\n            info.append('daemon')\n        return '<%s>' % ' '.join(info)\n\n    ##\n\n    def _bootstrap(self, parent_sentinel=None):\n        from . import util, context\n        global _current_process, _parent_process, _process_counter, _children\n\n        try:\n            if self._start_method is not None:\n                context._force_start_method(self._start_method)\n            _process_counter = itertools.count(1)\n            _children = set()\n            util._close_stdin()\n            old_process = _current_process\n            _current_process = self\n            _parent_process = _ParentProcess(\n                self._parent_name, self._parent_pid, parent_sentinel)\n            if threading._HAVE_THREAD_NATIVE_ID:\n                threading.main_thread()._set_native_id()\n            try:\n                util._finalizer_registry.clear()\n                util._run_after_forkers()\n            finally:\n                # delay finalization of the old process object until after\n                # _run_after_forkers() is executed\n                del old_process\n            util.info('child process calling self.run()')\n            try:\n                self.run()\n                exitcode = 0\n            finally:\n                util._exit_function()\n        except SystemExit as e:\n            if not e.args:\n                exitcode = 1\n            elif isinstance(e.args[0], int):\n                exitcode = e.args[0]\n            else:\n                sys.stderr.write(str(e.args[0]) + '\\n')\n                exitcode = 1\n        except:\n            exitcode = 1\n            import traceback\n            sys.stderr.write('Process %s:\\n' % self.name)\n            traceback.print_exc()\n        finally:\n            threading._shutdown()\n            util.info('process exiting with exitcode %d' % exitcode)\n            util._flush_std_streams()\n\n        return exitcode\n\n#\n# We subclass bytes to avoid accidental transmission of auth keys over network\n#\n\nclass AuthenticationString(bytes):\n    def __reduce__(self):\n        from .context import get_spawning_popen\n        if get_spawning_popen() is None:\n            raise TypeError(\n                'Pickling an AuthenticationString object is '\n                'disallowed for security reasons'\n                )\n        return AuthenticationString, (bytes(self),)\n\n\n#\n# Create object representing the parent process\n#\n\nclass _ParentProcess(BaseProcess):\n\n    def __init__(self, name, pid, sentinel):\n        self._identity = ()\n        self._name = name\n        self._pid = pid\n        self._parent_pid = None\n        self._popen = None\n        self._closed = False\n        self._sentinel = sentinel\n        self._config = {}\n\n    def is_alive(self):\n        from multiprocessing.connection import wait\n        return not wait([self._sentinel], timeout=0)\n\n    @property\n    def ident(self):\n        return self._pid\n\n    def join(self, timeout=None):\n        '''\n        Wait until parent process terminates\n        '''\n        from multiprocessing.connection import wait\n        wait([self._sentinel], timeout=timeout)\n\n    pid = ident\n\n#\n# Create object representing the main process\n#\n\nclass _MainProcess(BaseProcess):\n\n    def __init__(self):\n        self._identity = ()\n        self._name = 'MainProcess'\n        self._parent_pid = None\n        self._popen = None\n        self._closed = False\n        self._config = {'authkey': AuthenticationString(os.urandom(32)),\n                        'semprefix': '/mp'}\n        # Note that some versions of FreeBSD only allow named\n        # semaphores to have names of up to 14 characters.  Therefore\n        # we choose a short prefix.\n        #\n        # On MacOSX in a sandbox it may be necessary to use a\n        # different prefix -- see #19478.\n        #\n        # Everything in self._config will be inherited by descendant\n        # processes.\n\n    def close(self):\n        pass\n\n\n_parent_process = None\n_current_process = _MainProcess()\n_process_counter = itertools.count(1)\n_children = set()\ndel _MainProcess\n\n#\n# Give names to some return codes\n#\n\n_exitcode_to_name = {}\n\nfor name, signum in list(signal.__dict__.items()):\n    if name[:3]=='SIG' and '_' not in name:\n        _exitcode_to_name[-signum] = f'-{name}'\n\n# For debug and leak testing\n_dangling = WeakSet()\n", 432], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py": ["\"\"\"Weak reference support for Python.\n\nThis module is an implementation of PEP 205:\n\nhttp://www.python.org/dev/peps/pep-0205/\n\"\"\"\n\n# Naming convention: Variables named \"wr\" are weak reference objects;\n# they are called this instead of \"ref\" to avoid name collisions with\n# the module-global ref() function imported from _weakref.\n\nfrom _weakref import (\n     getweakrefcount,\n     getweakrefs,\n     ref,\n     proxy,\n     CallableProxyType,\n     ProxyType,\n     ReferenceType,\n     _remove_dead_weakref)\n\nfrom _weakrefset import WeakSet, _IterationGuard\n\nimport _collections_abc  # Import after _weakref to avoid circular import.\nimport sys\nimport itertools\n\nProxyTypes = (ProxyType, CallableProxyType)\n\n__all__ = [\"ref\", \"proxy\", \"getweakrefcount\", \"getweakrefs\",\n           \"WeakKeyDictionary\", \"ReferenceType\", \"ProxyType\",\n           \"CallableProxyType\", \"ProxyTypes\", \"WeakValueDictionary\",\n           \"WeakSet\", \"WeakMethod\", \"finalize\"]\n\n\nclass WeakMethod(ref):\n    \"\"\"\n    A custom `weakref.ref` subclass which simulates a weak reference to\n    a bound method, working around the lifetime problem of bound methods.\n    \"\"\"\n\n    __slots__ = \"_func_ref\", \"_meth_type\", \"_alive\", \"__weakref__\"\n\n    def __new__(cls, meth, callback=None):\n        try:\n            obj = meth.__self__\n            func = meth.__func__\n        except AttributeError:\n            raise TypeError(\"argument should be a bound method, not {}\"\n                            .format(type(meth))) from None\n        def _cb(arg):\n            # The self-weakref trick is needed to avoid creating a reference\n            # cycle.\n            self = self_wr()\n            if self._alive:\n                self._alive = False\n                if callback is not None:\n                    callback(self)\n        self = ref.__new__(cls, obj, _cb)\n        self._func_ref = ref(func, _cb)\n        self._meth_type = type(meth)\n        self._alive = True\n        self_wr = ref(self)\n        return self\n\n    def __call__(self):\n        obj = super().__call__()\n        func = self._func_ref()\n        if obj is None or func is None:\n            return None\n        return self._meth_type(func, obj)\n\n    def __eq__(self, other):\n        if isinstance(other, WeakMethod):\n            if not self._alive or not other._alive:\n                return self is other\n            return ref.__eq__(self, other) and self._func_ref == other._func_ref\n        return False\n\n    def __ne__(self, other):\n        if isinstance(other, WeakMethod):\n            if not self._alive or not other._alive:\n                return self is not other\n            return ref.__ne__(self, other) or self._func_ref != other._func_ref\n        return True\n\n    __hash__ = ref.__hash__\n\n\nclass WeakValueDictionary(_collections_abc.MutableMapping):\n    \"\"\"Mapping class that references values weakly.\n\n    Entries in the dictionary will be discarded when no strong\n    reference to the value exists anymore\n    \"\"\"\n    # We inherit the constructor without worrying about the input\n    # dictionary; since it uses our .update() method, we get the right\n    # checks (if the other dictionary is a WeakValueDictionary,\n    # objects are unwrapped on the way out, and we always wrap on the\n    # way in).\n\n    def __init__(self, other=(), /, **kw):\n        def remove(wr, selfref=ref(self), _atomic_removal=_remove_dead_weakref):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(wr.key)\n                else:\n                    # Atomic removal is necessary since this function\n                    # can be called asynchronously by the GC\n                    _atomic_removal(self.data, wr.key)\n        self._remove = remove\n        # A list of keys to be removed\n        self._pending_removals = []\n        self._iterating = set()\n        self.data = {}\n        self.update(other, **kw)\n\n    def _commit_removals(self):\n        l = self._pending_removals\n        d = self.data\n        # We shouldn't encounter any KeyError, because this method should\n        # always be called *before* mutating the dict.\n        while l:\n            key = l.pop()\n            _remove_dead_weakref(d, key)\n\n    def __getitem__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        o = self.data[key]()\n        if o is None:\n            raise KeyError(key)\n        else:\n            return o\n\n    def __delitem__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        del self.data[key]\n\n    def __len__(self):\n        if self._pending_removals:\n            self._commit_removals()\n        return len(self.data)\n\n    def __contains__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            o = self.data[key]()\n        except KeyError:\n            return False\n        return o is not None\n\n    def __repr__(self):\n        return \"<%s at %#x>\" % (self.__class__.__name__, id(self))\n\n    def __setitem__(self, key, value):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data[key] = KeyedRef(value, self._remove, key)\n\n    def copy(self):\n        if self._pending_removals:\n            self._commit_removals()\n        new = WeakValueDictionary()\n        with _IterationGuard(self):\n            for key, wr in self.data.items():\n                o = wr()\n                if o is not None:\n                    new[key] = o\n        return new\n\n    __copy__ = copy\n\n    def __deepcopy__(self, memo):\n        from copy import deepcopy\n        if self._pending_removals:\n            self._commit_removals()\n        new = self.__class__()\n        with _IterationGuard(self):\n            for key, wr in self.data.items():\n                o = wr()\n                if o is not None:\n                    new[deepcopy(key, memo)] = o\n        return new\n\n    def get(self, key, default=None):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            wr = self.data[key]\n        except KeyError:\n            return default\n        else:\n            o = wr()\n            if o is None:\n                # This should only happen\n                return default\n            else:\n                return o\n\n    def items(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for k, wr in self.data.items():\n                v = wr()\n                if v is not None:\n                    yield k, v\n\n    def keys(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for k, wr in self.data.items():\n                if wr() is not None:\n                    yield k\n\n    __iter__ = keys\n\n    def itervaluerefs(self):\n        \"\"\"Return an iterator that yields the weak references to the values.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the values around longer than needed.\n\n        \"\"\"\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            yield from self.data.values()\n\n    def values(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for wr in self.data.values():\n                obj = wr()\n                if obj is not None:\n                    yield obj\n\n    def popitem(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            key, wr = self.data.popitem()\n            o = wr()\n            if o is not None:\n                return key, o\n\n    def pop(self, key, *args):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            o = self.data.pop(key)()\n        except KeyError:\n            o = None\n        if o is None:\n            if args:\n                return args[0]\n            else:\n                raise KeyError(key)\n        else:\n            return o\n\n    def setdefault(self, key, default=None):\n        try:\n            o = self.data[key]()\n        except KeyError:\n            o = None\n        if o is None:\n            if self._pending_removals:\n                self._commit_removals()\n            self.data[key] = KeyedRef(default, self._remove, key)\n            return default\n        else:\n            return o\n\n    def update(self, other=None, /, **kwargs):\n        if self._pending_removals:\n            self._commit_removals()\n        d = self.data\n        if other is not None:\n            if not hasattr(other, \"items\"):\n                other = dict(other)\n            for key, o in other.items():\n                d[key] = KeyedRef(o, self._remove, key)\n        for key, o in kwargs.items():\n            d[key] = KeyedRef(o, self._remove, key)\n\n    def valuerefs(self):\n        \"\"\"Return a list of weak references to the values.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the values around longer than needed.\n\n        \"\"\"\n        if self._pending_removals:\n            self._commit_removals()\n        return list(self.data.values())\n\n\nclass KeyedRef(ref):\n    \"\"\"Specialized reference that includes a key corresponding to the value.\n\n    This is used in the WeakValueDictionary to avoid having to create\n    a function object for each key stored in the mapping.  A shared\n    callback object can use the 'key' attribute of a KeyedRef instead\n    of getting a reference to the key from an enclosing scope.\n\n    \"\"\"\n\n    __slots__ = \"key\",\n\n    def __new__(type, ob, callback, key):\n        self = ref.__new__(type, ob, callback)\n        self.key = key\n        return self\n\n    def __init__(self, ob, callback, key):\n        super().__init__(ob, callback)\n\n\nclass WeakKeyDictionary(_collections_abc.MutableMapping):\n    \"\"\" Mapping class that references keys weakly.\n\n    Entries in the dictionary will be discarded when there is no\n    longer a strong reference to the key. This can be used to\n    associate additional data with an object owned by other parts of\n    an application without adding attributes to those objects. This\n    can be especially useful with objects that override attribute\n    accesses.\n    \"\"\"\n\n    def __init__(self, dict=None):\n        self.data = {}\n        def remove(k, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(k)\n                else:\n                    del self.data[k]\n        self._remove = remove\n        # A list of dead weakrefs (keys to be removed)\n        self._pending_removals = []\n        self._iterating = set()\n        self._dirty_len = False\n        if dict is not None:\n            self.update(dict)\n\n    def _commit_removals(self):\n        # NOTE: We don't need to call this method before mutating the dict,\n        # because a dead weakref never compares equal to a live weakref,\n        # even if they happened to refer to equal objects.\n        # However, it means keys may already have been removed.\n        l = self._pending_removals\n        d = self.data\n        while l:\n            try:\n                del d[l.pop()]\n            except KeyError:\n                pass\n\n    def _scrub_removals(self):\n        d = self.data\n        self._pending_removals = [k for k in self._pending_removals if k in d]\n        self._dirty_len = False\n\n    def __delitem__(self, key):\n        self._dirty_len = True\n        del self.data[ref(key)]\n\n    def __getitem__(self, key):\n        return self.data[ref(key)]\n\n    def __len__(self):\n        if self._dirty_len and self._pending_removals:\n            # self._pending_removals may still contain keys which were\n            # explicitly removed, we have to scrub them (see issue #21173).\n            self._scrub_removals()\n        return len(self.data) - len(self._pending_removals)\n\n    def __repr__(self):\n        return \"<%s at %#x>\" % (self.__class__.__name__, id(self))\n\n    def __setitem__(self, key, value):\n        self.data[ref(key, self._remove)] = value\n\n    def copy(self):\n        new = WeakKeyDictionary()\n        with _IterationGuard(self):\n            for key, value in self.data.items():\n                o = key()\n                if o is not None:\n                    new[o] = value\n        return new\n\n    __copy__ = copy\n\n    def __deepcopy__(self, memo):\n        from copy import deepcopy\n        new = self.__class__()\n        with _IterationGuard(self):\n            for key, value in self.data.items():\n                o = key()\n                if o is not None:\n                    new[o] = deepcopy(value, memo)\n        return new\n\n    def get(self, key, default=None):\n        return self.data.get(ref(key),default)\n\n    def __contains__(self, key):\n        try:\n            wr = ref(key)\n        except TypeError:\n            return False\n        return wr in self.data\n\n    def items(self):\n        with _IterationGuard(self):\n            for wr, value in self.data.items():\n                key = wr()\n                if key is not None:\n                    yield key, value\n\n    def keys(self):\n        with _IterationGuard(self):\n            for wr in self.data:\n                obj = wr()\n                if obj is not None:\n                    yield obj\n\n    __iter__ = keys\n\n    def values(self):\n        with _IterationGuard(self):\n            for wr, value in self.data.items():\n                if wr() is not None:\n                    yield value\n\n    def keyrefs(self):\n        \"\"\"Return a list of weak references to the keys.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the keys around longer than needed.\n\n        \"\"\"\n        return list(self.data)\n\n    def popitem(self):\n        self._dirty_len = True\n        while True:\n            key, value = self.data.popitem()\n            o = key()\n            if o is not None:\n                return o, value\n\n    def pop(self, key, *args):\n        self._dirty_len = True\n        return self.data.pop(ref(key), *args)\n\n    def setdefault(self, key, default=None):\n        return self.data.setdefault(ref(key, self._remove),default)\n\n    def update(self, dict=None, /, **kwargs):\n        d = self.data\n        if dict is not None:\n            if not hasattr(dict, \"items\"):\n                dict = type({})(dict)\n            for key, value in dict.items():\n                d[ref(key, self._remove)] = value\n        if len(kwargs):\n            self.update(kwargs)\n\n\nclass finalize:\n    \"\"\"Class for finalization of weakrefable objects\n\n    finalize(obj, func, *args, **kwargs) returns a callable finalizer\n    object which will be called when obj is garbage collected. The\n    first time the finalizer is called it evaluates func(*arg, **kwargs)\n    and returns the result. After this the finalizer is dead, and\n    calling it just returns None.\n\n    When the program exits any remaining finalizers for which the\n    atexit attribute is true will be run in reverse order of creation.\n    By default atexit is true.\n    \"\"\"\n\n    # Finalizer objects don't have any state of their own.  They are\n    # just used as keys to lookup _Info objects in the registry.  This\n    # ensures that they cannot be part of a ref-cycle.\n\n    __slots__ = ()\n    _registry = {}\n    _shutdown = False\n    _index_iter = itertools.count()\n    _dirty = False\n    _registered_with_atexit = False\n\n    class _Info:\n        __slots__ = (\"weakref\", \"func\", \"args\", \"kwargs\", \"atexit\", \"index\")\n\n    def __init__(*args, **kwargs):\n        if len(args) >= 3:\n            self, obj, func, *args = args\n        elif not args:\n            raise TypeError(\"descriptor '__init__' of 'finalize' object \"\n                            \"needs an argument\")\n        else:\n            if 'func' not in kwargs:\n                raise TypeError('finalize expected at least 2 positional '\n                                'arguments, got %d' % (len(args)-1))\n            func = kwargs.pop('func')\n            if len(args) >= 2:\n                self, obj, *args = args\n                import warnings\n                warnings.warn(\"Passing 'func' as keyword argument is deprecated\",\n                              DeprecationWarning, stacklevel=2)\n            else:\n                if 'obj' not in kwargs:\n                    raise TypeError('finalize expected at least 2 positional '\n                                    'arguments, got %d' % (len(args)-1))\n                obj = kwargs.pop('obj')\n                self, *args = args\n                import warnings\n                warnings.warn(\"Passing 'obj' as keyword argument is deprecated\",\n                              DeprecationWarning, stacklevel=2)\n        args = tuple(args)\n\n        if not self._registered_with_atexit:\n            # We may register the exit function more than once because\n            # of a thread race, but that is harmless\n            import atexit\n            atexit.register(self._exitfunc)\n            finalize._registered_with_atexit = True\n        info = self._Info()\n        info.weakref = ref(obj, self)\n        info.func = func\n        info.args = args\n        info.kwargs = kwargs or None\n        info.atexit = True\n        info.index = next(self._index_iter)\n        self._registry[self] = info\n        finalize._dirty = True\n    __init__.__text_signature__ = '($self, obj, func, /, *args, **kwargs)'\n\n    def __call__(self, _=None):\n        \"\"\"If alive then mark as dead and return func(*args, **kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.pop(self, None)\n        if info and not self._shutdown:\n            return info.func(*info.args, **(info.kwargs or {}))\n\n    def detach(self):\n        \"\"\"If alive then mark as dead and return (obj, func, args, kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is not None and self._registry.pop(self, None):\n            return (obj, info.func, info.args, info.kwargs or {})\n\n    def peek(self):\n        \"\"\"If alive then return (obj, func, args, kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is not None:\n            return (obj, info.func, info.args, info.kwargs or {})\n\n    @property\n    def alive(self):\n        \"\"\"Whether finalizer is alive\"\"\"\n        return self in self._registry\n\n    @property\n    def atexit(self):\n        \"\"\"Whether finalizer should be called at exit\"\"\"\n        info = self._registry.get(self)\n        return bool(info) and info.atexit\n\n    @atexit.setter\n    def atexit(self, value):\n        info = self._registry.get(self)\n        if info:\n            info.atexit = bool(value)\n\n    def __repr__(self):\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is None:\n            return '<%s object at %#x; dead>' % (type(self).__name__, id(self))\n        else:\n            return '<%s object at %#x; for %r at %#x>' % \\\n                (type(self).__name__, id(self), type(obj).__name__, id(obj))\n\n    @classmethod\n    def _select_for_exit(cls):\n        # Return live finalizers marked for exit, oldest first\n        L = [(f,i) for (f,i) in cls._registry.items() if i.atexit]\n        L.sort(key=lambda item:item[1].index)\n        return [f for (f,i) in L]\n\n    @classmethod\n    def _exitfunc(cls):\n        # At shutdown invoke finalizers for which atexit is true.\n        # This is called once all other non-daemonic threads have been\n        # joined.\n        reenable_gc = False\n        try:\n            if cls._registry:\n                import gc\n                if gc.isenabled():\n                    reenable_gc = True\n                    gc.disable()\n                pending = None\n                while True:\n                    if pending is None or finalize._dirty:\n                        pending = cls._select_for_exit()\n                        finalize._dirty = False\n                    if not pending:\n                        break\n                    f = pending.pop()\n                    try:\n                        # gc is disabled, so (assuming no daemonic\n                        # threads) the following is the only line in\n                        # this function which might trigger creation\n                        # of a new finalizer\n                        f()\n                    except Exception:\n                        sys.excepthook(*sys.exc_info())\n                    assert f not in cls._registry\n        finally:\n            # prevent any more finalizers from executing during shutdown\n            finalize._shutdown = True\n            if reenable_gc:\n                gc.enable()\n", 650], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py": ["# Copyright 2009 Brian Quinlan. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Implements ThreadPoolExecutor.\"\"\"\n\n__author__ = 'Brian Quinlan (brian@sweetapp.com)'\n\nimport atexit\nfrom concurrent.futures import _base\nimport itertools\nimport queue\nimport threading\nimport weakref\nimport os\n\n# Workers are created as daemon threads. This is done to allow the interpreter\n# to exit when there are still idle threads in a ThreadPoolExecutor's thread\n# pool (i.e. shutdown() was not called). However, allowing workers to die with\n# the interpreter has two undesirable properties:\n#   - The workers would still be running during interpreter shutdown,\n#     meaning that they would fail in unpredictable ways.\n#   - The workers could be killed while evaluating a work item, which could\n#     be bad if the callable being evaluated has external side-effects e.g.\n#     writing to a file.\n#\n# To work around this problem, an exit handler is installed which tells the\n# workers to exit when their work queues are empty and then waits until the\n# threads finish.\n\n_threads_queues = weakref.WeakKeyDictionary()\n_shutdown = False\n\ndef _python_exit():\n    global _shutdown\n    _shutdown = True\n    items = list(_threads_queues.items())\n    for t, q in items:\n        q.put(None)\n    for t, q in items:\n        t.join()\n\natexit.register(_python_exit)\n\n\nclass _WorkItem(object):\n    def __init__(self, future, fn, args, kwargs):\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n\n    def run(self):\n        if not self.future.set_running_or_notify_cancel():\n            return\n\n        try:\n            result = self.fn(*self.args, **self.kwargs)\n        except BaseException as exc:\n            self.future.set_exception(exc)\n            # Break a reference cycle with the exception 'exc'\n            self = None\n        else:\n            self.future.set_result(result)\n\n\ndef _worker(executor_reference, work_queue, initializer, initargs):\n    if initializer is not None:\n        try:\n            initializer(*initargs)\n        except BaseException:\n            _base.LOGGER.critical('Exception in initializer:', exc_info=True)\n            executor = executor_reference()\n            if executor is not None:\n                executor._initializer_failed()\n            return\n    try:\n        while True:\n            work_item = work_queue.get(block=True)\n            if work_item is not None:\n                work_item.run()\n                # Delete references to object. See issue16284\n                del work_item\n\n                # attempt to increment idle count\n                executor = executor_reference()\n                if executor is not None:\n                    executor._idle_semaphore.release()\n                del executor\n                continue\n\n            executor = executor_reference()\n            # Exit if:\n            #   - The interpreter is shutting down OR\n            #   - The executor that owns the worker has been collected OR\n            #   - The executor that owns the worker has been shutdown.\n            if _shutdown or executor is None or executor._shutdown:\n                # Flag the executor as shutting down as early as possible if it\n                # is not gc-ed yet.\n                if executor is not None:\n                    executor._shutdown = True\n                # Notice other workers\n                work_queue.put(None)\n                return\n            del executor\n    except BaseException:\n        _base.LOGGER.critical('Exception in worker', exc_info=True)\n\n\nclass BrokenThreadPool(_base.BrokenExecutor):\n    \"\"\"\n    Raised when a worker thread in a ThreadPoolExecutor failed initializing.\n    \"\"\"\n\n\nclass ThreadPoolExecutor(_base.Executor):\n\n    # Used to assign unique thread names when thread_name_prefix is not supplied.\n    _counter = itertools.count().__next__\n\n    def __init__(self, max_workers=None, thread_name_prefix='',\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.\n\n        Args:\n            max_workers: The maximum number of threads that can be used to\n                execute the given calls.\n            thread_name_prefix: An optional name prefix to give our threads.\n            initializer: A callable used to initialize worker threads.\n            initargs: A tuple of arguments to pass to the initializer.\n        \"\"\"\n        if max_workers is None:\n            # ThreadPoolExecutor is often used to:\n            # * CPU bound task which releases GIL\n            # * I/O bound task (which releases GIL, of course)\n            #\n            # We use cpu_count + 4 for both types of tasks.\n            # But we limit it to 32 to avoid consuming surprisingly large resource\n            # on many core machine.\n            max_workers = min(32, (os.cpu_count() or 1) + 4)\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be greater than 0\")\n\n        if initializer is not None and not callable(initializer):\n            raise TypeError(\"initializer must be a callable\")\n\n        self._max_workers = max_workers\n        self._work_queue = queue.SimpleQueue()\n        self._idle_semaphore = threading.Semaphore(0)\n        self._threads = set()\n        self._broken = False\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._thread_name_prefix = (thread_name_prefix or\n                                    (\"ThreadPoolExecutor-%d\" % self._counter()))\n        self._initializer = initializer\n        self._initargs = initargs\n\n    def submit(*args, **kwargs):\n        if len(args) >= 2:\n            self, fn, *args = args\n        elif not args:\n            raise TypeError(\"descriptor 'submit' of 'ThreadPoolExecutor' object \"\n                            \"needs an argument\")\n        elif 'fn' in kwargs:\n            fn = kwargs.pop('fn')\n            self, *args = args\n            import warnings\n            warnings.warn(\"Passing 'fn' as keyword argument is deprecated\",\n                          DeprecationWarning, stacklevel=2)\n        else:\n            raise TypeError('submit expected at least 1 positional argument, '\n                            'got %d' % (len(args)-1))\n\n        with self._shutdown_lock:\n            if self._broken:\n                raise BrokenThreadPool(self._broken)\n\n            if self._shutdown:\n                raise RuntimeError('cannot schedule new futures after shutdown')\n            if _shutdown:\n                raise RuntimeError('cannot schedule new futures after '\n                                   'interpreter shutdown')\n\n            f = _base.Future()\n            w = _WorkItem(f, fn, args, kwargs)\n\n            self._work_queue.put(w)\n            self._adjust_thread_count()\n            return f\n    submit.__text_signature__ = _base.Executor.submit.__text_signature__\n    submit.__doc__ = _base.Executor.submit.__doc__\n\n    def _adjust_thread_count(self):\n        # if idle threads are available, don't spin new threads\n        if self._idle_semaphore.acquire(timeout=0):\n            return\n\n        # When the executor gets lost, the weakref callback will wake up\n        # the worker threads.\n        def weakref_cb(_, q=self._work_queue):\n            q.put(None)\n\n        num_threads = len(self._threads)\n        if num_threads < self._max_workers:\n            thread_name = '%s_%d' % (self._thread_name_prefix or self,\n                                     num_threads)\n            t = threading.Thread(name=thread_name, target=_worker,\n                                 args=(weakref.ref(self, weakref_cb),\n                                       self._work_queue,\n                                       self._initializer,\n                                       self._initargs))\n            t.daemon = True\n            t.start()\n            self._threads.add(t)\n            _threads_queues[t] = self._work_queue\n\n    def _initializer_failed(self):\n        with self._shutdown_lock:\n            self._broken = ('A thread initializer failed, the thread pool '\n                            'is not usable anymore')\n            # Drain work queue and mark pending futures failed\n            while True:\n                try:\n                    work_item = self._work_queue.get_nowait()\n                except queue.Empty:\n                    break\n                if work_item is not None:\n                    work_item.future.set_exception(BrokenThreadPool(self._broken))\n\n    def shutdown(self, wait=True):\n        with self._shutdown_lock:\n            self._shutdown = True\n            self._work_queue.put(None)\n        if wait:\n            for t in self._threads:\n                t.join()\n    shutdown.__doc__ = _base.Executor.shutdown.__doc__\n", 237], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/__init__.py": ["# Copyright 2009 Brian Quinlan. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Execute computations asynchronously using threads or processes.\"\"\"\n\n__author__ = 'Brian Quinlan (brian@sweetapp.com)'\n\nfrom concurrent.futures._base import (FIRST_COMPLETED,\n                                      FIRST_EXCEPTION,\n                                      ALL_COMPLETED,\n                                      CancelledError,\n                                      TimeoutError,\n                                      InvalidStateError,\n                                      BrokenExecutor,\n                                      Future,\n                                      Executor,\n                                      wait,\n                                      as_completed)\n\n__all__ = (\n    'FIRST_COMPLETED',\n    'FIRST_EXCEPTION',\n    'ALL_COMPLETED',\n    'CancelledError',\n    'TimeoutError',\n    'BrokenExecutor',\n    'Future',\n    'Executor',\n    'wait',\n    'as_completed',\n    'ProcessPoolExecutor',\n    'ThreadPoolExecutor',\n)\n\n\ndef __dir__():\n    return __all__ + ('__author__', '__doc__')\n\n\ndef __getattr__(name):\n    global ProcessPoolExecutor, ThreadPoolExecutor\n\n    if name == 'ProcessPoolExecutor':\n        from .process import ProcessPoolExecutor as pe\n        ProcessPoolExecutor = pe\n        return pe\n\n    if name == 'ThreadPoolExecutor':\n        from .thread import ThreadPoolExecutor as te\n        ThreadPoolExecutor = te\n        return te\n\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")\n", 53], "/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py": ["# Copyright 2009 Brian Quinlan. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n__author__ = 'Brian Quinlan (brian@sweetapp.com)'\n\nimport collections\nimport logging\nimport threading\nimport time\n\nFIRST_COMPLETED = 'FIRST_COMPLETED'\nFIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n\n_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",\n    RUNNING: \"running\",\n    CANCELLED: \"cancelled\",\n    CANCELLED_AND_NOTIFIED: \"cancelled\",\n    FINISHED: \"finished\"\n}\n\n# Logger for internal use by the futures package.\nLOGGER = logging.getLogger(\"concurrent.futures\")\n\nclass Error(Exception):\n    \"\"\"Base class for all future-related exceptions.\"\"\"\n    pass\n\nclass CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\n\nclass TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass\n\nclass InvalidStateError(Error):\n    \"\"\"The operation is not allowed in this state.\"\"\"\n    pass\n\nclass _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()\n        self.finished_futures = []\n\n    def add_result(self, future):\n        self.finished_futures.append(future)\n\n    def add_exception(self, future):\n        self.finished_futures.append(future)\n\n    def add_cancelled(self, future):\n        self.finished_futures.append(future)\n\nclass _AsCompletedWaiter(_Waiter):\n    \"\"\"Used by as_completed().\"\"\"\n\n    def __init__(self):\n        super(_AsCompletedWaiter, self).__init__()\n        self.lock = threading.Lock()\n\n    def add_result(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_result(future)\n            self.event.set()\n\n    def add_exception(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_exception(future)\n            self.event.set()\n\n    def add_cancelled(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_cancelled(future)\n            self.event.set()\n\nclass _FirstCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_COMPLETED).\"\"\"\n\n    def add_result(self, future):\n        super().add_result(future)\n        self.event.set()\n\n    def add_exception(self, future):\n        super().add_exception(future)\n        self.event.set()\n\n    def add_cancelled(self, future):\n        super().add_cancelled(future)\n        self.event.set()\n\nclass _AllCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_EXCEPTION and ALL_COMPLETED).\"\"\"\n\n    def __init__(self, num_pending_calls, stop_on_exception):\n        self.num_pending_calls = num_pending_calls\n        self.stop_on_exception = stop_on_exception\n        self.lock = threading.Lock()\n        super().__init__()\n\n    def _decrement_pending_calls(self):\n        with self.lock:\n            self.num_pending_calls -= 1\n            if not self.num_pending_calls:\n                self.event.set()\n\n    def add_result(self, future):\n        super().add_result(future)\n        self._decrement_pending_calls()\n\n    def add_exception(self, future):\n        super().add_exception(future)\n        if self.stop_on_exception:\n            self.event.set()\n        else:\n            self._decrement_pending_calls()\n\n    def add_cancelled(self, future):\n        super().add_cancelled(future)\n        self._decrement_pending_calls()\n\nclass _AcquireFutures(object):\n    \"\"\"A context manager that does an ordered acquire of Future conditions.\"\"\"\n\n    def __init__(self, futures):\n        self.futures = sorted(futures, key=id)\n\n    def __enter__(self):\n        for future in self.futures:\n            future._condition.acquire()\n\n    def __exit__(self, *args):\n        for future in self.futures:\n            future._condition.release()\n\ndef _create_and_install_waiters(fs, return_when):\n    if return_when == _AS_COMPLETED:\n        waiter = _AsCompletedWaiter()\n    elif return_when == FIRST_COMPLETED:\n        waiter = _FirstCompletedWaiter()\n    else:\n        pending_count = sum(\n                f._state not in [CANCELLED_AND_NOTIFIED, FINISHED] for f in fs)\n\n        if return_when == FIRST_EXCEPTION:\n            waiter = _AllCompletedWaiter(pending_count, stop_on_exception=True)\n        elif return_when == ALL_COMPLETED:\n            waiter = _AllCompletedWaiter(pending_count, stop_on_exception=False)\n        else:\n            raise ValueError(\"Invalid return condition: %r\" % return_when)\n\n    for f in fs:\n        f._waiters.append(waiter)\n\n    return waiter\n\n\ndef _yield_finished_futures(fs, waiter, ref_collect):\n    \"\"\"\n    Iterate on the list *fs*, yielding finished futures one by one in\n    reverse order.\n    Before yielding a future, *waiter* is removed from its waiters\n    and the future is removed from each set in the collection of sets\n    *ref_collect*.\n\n    The aim of this function is to avoid keeping stale references after\n    the future is yielded and before the iterator resumes.\n    \"\"\"\n    while fs:\n        f = fs[-1]\n        for futures_set in ref_collect:\n            futures_set.remove(f)\n        with f._condition:\n            f._waiters.remove(waiter)\n        del f\n        # Careful not to keep a reference to the popped value\n        yield fs.pop()\n\n\ndef as_completed(fs, timeout=None):\n    \"\"\"An iterator over the given futures that yields each as it completes.\n\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            iterate over.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n\n    Returns:\n        An iterator that yields the given Futures as they complete (finished or\n        cancelled). If any given Futures are duplicated, they will be returned\n        once.\n\n    Raises:\n        TimeoutError: If the entire result iterator could not be generated\n            before the given timeout.\n    \"\"\"\n    if timeout is not None:\n        end_time = timeout + time.monotonic()\n\n    fs = set(fs)\n    total_futures = len(fs)\n    with _AcquireFutures(fs):\n        finished = set(\n                f for f in fs\n                if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])\n        pending = fs - finished\n        waiter = _create_and_install_waiters(fs, _AS_COMPLETED)\n    finished = list(finished)\n    try:\n        yield from _yield_finished_futures(finished, waiter,\n                                           ref_collect=(fs,))\n\n        while pending:\n            if timeout is None:\n                wait_timeout = None\n            else:\n                wait_timeout = end_time - time.monotonic()\n                if wait_timeout < 0:\n                    raise TimeoutError(\n                            '%d (of %d) futures unfinished' % (\n                            len(pending), total_futures))\n\n            waiter.event.wait(wait_timeout)\n\n            with waiter.lock:\n                finished = waiter.finished_futures\n                waiter.finished_futures = []\n                waiter.event.clear()\n\n            # reverse to keep finishing order\n            finished.reverse()\n            yield from _yield_finished_futures(finished, waiter,\n                                               ref_collect=(fs, pending))\n\n    finally:\n        # Remove waiter from unfinished futures\n        for f in fs:\n            with f._condition:\n                f._waiters.remove(waiter)\n\nDoneAndNotDoneFutures = collections.namedtuple(\n        'DoneAndNotDoneFutures', 'done not_done')\ndef wait(fs, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the futures in the given sequence to complete.\n\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            wait upon.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        return_when: Indicates when this function should return. The options\n            are:\n\n            FIRST_COMPLETED - Return when any future finishes or is\n                              cancelled.\n            FIRST_EXCEPTION - Return when any future finishes by raising an\n                              exception. If no future raises an exception\n                              then it is equivalent to ALL_COMPLETED.\n            ALL_COMPLETED -   Return when all futures finish or are cancelled.\n\n    Returns:\n        A named 2-tuple of sets. The first set, named 'done', contains the\n        futures that completed (is finished or cancelled) before the wait\n        completed. The second set, named 'not_done', contains uncompleted\n        futures.\n    \"\"\"\n    with _AcquireFutures(fs):\n        done = set(f for f in fs\n                   if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])\n        not_done = set(fs) - done\n\n        if (return_when == FIRST_COMPLETED) and done:\n            return DoneAndNotDoneFutures(done, not_done)\n        elif (return_when == FIRST_EXCEPTION) and done:\n            if any(f for f in done\n                   if not f.cancelled() and f.exception() is not None):\n                return DoneAndNotDoneFutures(done, not_done)\n\n        if len(done) == len(fs):\n            return DoneAndNotDoneFutures(done, not_done)\n\n        waiter = _create_and_install_waiters(fs, return_when)\n\n    waiter.event.wait(timeout)\n    for f in fs:\n        with f._condition:\n            f._waiters.remove(waiter)\n\n    done.update(waiter.finished_futures)\n    return DoneAndNotDoneFutures(done, set(fs) - done)\n\nclass Future(object):\n    \"\"\"Represents the result of an asynchronous computation.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the future. Should not be called by clients.\"\"\"\n        self._condition = threading.Condition()\n        self._state = PENDING\n        self._result = None\n        self._exception = None\n        self._waiters = []\n        self._done_callbacks = []\n\n    def _invoke_callbacks(self):\n        for callback in self._done_callbacks:\n            try:\n                callback(self)\n            except Exception:\n                LOGGER.exception('exception calling callback for %r', self)\n\n    def __repr__(self):\n        with self._condition:\n            if self._state == FINISHED:\n                if self._exception:\n                    return '<%s at %#x state=%s raised %s>' % (\n                        self.__class__.__name__,\n                        id(self),\n                        _STATE_TO_DESCRIPTION_MAP[self._state],\n                        self._exception.__class__.__name__)\n                else:\n                    return '<%s at %#x state=%s returned %s>' % (\n                        self.__class__.__name__,\n                        id(self),\n                        _STATE_TO_DESCRIPTION_MAP[self._state],\n                        self._result.__class__.__name__)\n            return '<%s at %#x state=%s>' % (\n                    self.__class__.__name__,\n                    id(self),\n                   _STATE_TO_DESCRIPTION_MAP[self._state])\n\n    def cancel(self):\n        \"\"\"Cancel the future if possible.\n\n        Returns True if the future was cancelled, False otherwise. A future\n        cannot be cancelled if it is running or has already completed.\n        \"\"\"\n        with self._condition:\n            if self._state in [RUNNING, FINISHED]:\n                return False\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                return True\n\n            self._state = CANCELLED\n            self._condition.notify_all()\n\n        self._invoke_callbacks()\n        return True\n\n    def cancelled(self):\n        \"\"\"Return True if the future was cancelled.\"\"\"\n        with self._condition:\n            return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]\n\n    def running(self):\n        \"\"\"Return True if the future is currently executing.\"\"\"\n        with self._condition:\n            return self._state == RUNNING\n\n    def done(self):\n        \"\"\"Return True of the future was cancelled or finished executing.\"\"\"\n        with self._condition:\n            return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]\n\n    def __get_result(self):\n        if self._exception:\n            raise self._exception\n        else:\n            return self._result\n\n    def add_done_callback(self, fn):\n        \"\"\"Attaches a callable that will be called when the future finishes.\n\n        Args:\n            fn: A callable that will be called with this future as its only\n                argument when the future completes or is cancelled. The callable\n                will always be called by a thread in the same process in which\n                it was added. If the future has already completed or been\n                cancelled then the callable will be called immediately. These\n                callables are called in the order that they were added.\n        \"\"\"\n        with self._condition:\n            if self._state not in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]:\n                self._done_callbacks.append(fn)\n                return\n        try:\n            fn(self)\n        except Exception:\n            LOGGER.exception('exception calling callback for %r', self)\n\n    def result(self, timeout=None):\n        \"\"\"Return the result of the call that the future represents.\n\n        Args:\n            timeout: The number of seconds to wait for the result if the future\n                isn't done. If None, then there is no limit on the wait time.\n\n        Returns:\n            The result of the call that the future represents.\n\n        Raises:\n            CancelledError: If the future was cancelled.\n            TimeoutError: If the future didn't finish executing before the given\n                timeout.\n            Exception: If the call raised then that exception will be raised.\n        \"\"\"\n        with self._condition:\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self.__get_result()\n\n            self._condition.wait(timeout)\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self.__get_result()\n            else:\n                raise TimeoutError()\n\n    def exception(self, timeout=None):\n        \"\"\"Return the exception raised by the call that the future represents.\n\n        Args:\n            timeout: The number of seconds to wait for the exception if the\n                future isn't done. If None, then there is no limit on the wait\n                time.\n\n        Returns:\n            The exception raised by the call that the future represents or None\n            if the call completed without raising.\n\n        Raises:\n            CancelledError: If the future was cancelled.\n            TimeoutError: If the future didn't finish executing before the given\n                timeout.\n        \"\"\"\n\n        with self._condition:\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self._exception\n\n            self._condition.wait(timeout)\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self._exception\n            else:\n                raise TimeoutError()\n\n    # The following methods should only be used by Executors and in tests.\n    def set_running_or_notify_cancel(self):\n        \"\"\"Mark the future as running or process any cancel notifications.\n\n        Should only be used by Executor implementations and unit tests.\n\n        If the future has been cancelled (cancel() was called and returned\n        True) then any threads waiting on the future completing (though calls\n        to as_completed() or wait()) are notified and False is returned.\n\n        If the future was not cancelled then it is put in the running state\n        (future calls to running() will return True) and True is returned.\n\n        This method should be called by Executor implementations before\n        executing the work associated with this future. If this method returns\n        False then the work should not be executed.\n\n        Returns:\n            False if the Future was cancelled, True otherwise.\n\n        Raises:\n            RuntimeError: if this method was already called or if set_result()\n                or set_exception() was called.\n        \"\"\"\n        with self._condition:\n            if self._state == CANCELLED:\n                self._state = CANCELLED_AND_NOTIFIED\n                for waiter in self._waiters:\n                    waiter.add_cancelled(self)\n                # self._condition.notify_all() is not necessary because\n                # self.cancel() triggers a notification.\n                return False\n            elif self._state == PENDING:\n                self._state = RUNNING\n                return True\n            else:\n                LOGGER.critical('Future %s in unexpected state: %s',\n                                id(self),\n                                self._state)\n                raise RuntimeError('Future in unexpected state')\n\n    def set_result(self, result):\n        \"\"\"Sets the return value of work associated with the future.\n\n        Should only be used by Executor implementations and unit tests.\n        \"\"\"\n        with self._condition:\n            if self._state in {CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED}:\n                raise InvalidStateError('{}: {!r}'.format(self._state, self))\n            self._result = result\n            self._state = FINISHED\n            for waiter in self._waiters:\n                waiter.add_result(self)\n            self._condition.notify_all()\n        self._invoke_callbacks()\n\n    def set_exception(self, exception):\n        \"\"\"Sets the result of the future as being the given exception.\n\n        Should only be used by Executor implementations and unit tests.\n        \"\"\"\n        with self._condition:\n            if self._state in {CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED}:\n                raise InvalidStateError('{}: {!r}'.format(self._state, self))\n            self._exception = exception\n            self._state = FINISHED\n            for waiter in self._waiters:\n                waiter.add_exception(self)\n            self._condition.notify_all()\n        self._invoke_callbacks()\n\nclass Executor(object):\n    \"\"\"This is an abstract base class for concrete asynchronous executors.\"\"\"\n\n    def submit(*args, **kwargs):\n        \"\"\"Submits a callable to be executed with the given arguments.\n\n        Schedules the callable to be executed as fn(*args, **kwargs) and returns\n        a Future instance representing the execution of the callable.\n\n        Returns:\n            A Future representing the given call.\n        \"\"\"\n        if len(args) >= 2:\n            pass\n        elif not args:\n            raise TypeError(\"descriptor 'submit' of 'Executor' object \"\n                            \"needs an argument\")\n        elif 'fn' in kwargs:\n            import warnings\n            warnings.warn(\"Passing 'fn' as keyword argument is deprecated\",\n                          DeprecationWarning, stacklevel=2)\n        else:\n            raise TypeError('submit expected at least 1 positional argument, '\n                            'got %d' % (len(args)-1))\n\n        raise NotImplementedError()\n    submit.__text_signature__ = '($self, fn, /, *args, **kwargs)'\n\n    def map(self, fn, *iterables, timeout=None, chunksize=1):\n        \"\"\"Returns an iterator equivalent to map(fn, iter).\n\n        Args:\n            fn: A callable that will take as many arguments as there are\n                passed iterables.\n            timeout: The maximum number of seconds to wait. If None, then there\n                is no limit on the wait time.\n            chunksize: The size of the chunks the iterable will be broken into\n                before being passed to a child process. This argument is only\n                used by ProcessPoolExecutor; it is ignored by\n                ThreadPoolExecutor.\n\n        Returns:\n            An iterator equivalent to: map(func, *iterables) but the calls may\n            be evaluated out-of-order.\n\n        Raises:\n            TimeoutError: If the entire result iterator could not be generated\n                before the given timeout.\n            Exception: If fn(*args) raises for any values.\n        \"\"\"\n        if timeout is not None:\n            end_time = timeout + time.monotonic()\n\n        fs = [self.submit(fn, *args) for args in zip(*iterables)]\n\n        # Yield must be hidden in closure so that the futures are submitted\n        # before the first iterator value is required.\n        def result_iterator():\n            try:\n                # reverse to keep finishing order\n                fs.reverse()\n                while fs:\n                    # Careful not to keep a reference to the popped future\n                    if timeout is None:\n                        yield fs.pop().result()\n                    else:\n                        yield fs.pop().result(end_time - time.monotonic())\n            finally:\n                for future in fs:\n                    future.cancel()\n        return result_iterator()\n\n    def shutdown(self, wait=True):\n        \"\"\"Clean-up the resources associated with the Executor.\n\n        It is safe to call this method several times. Otherwise, no other\n        methods can be called after this one.\n\n        Args:\n            wait: If True then shutdown will not return until all running\n                futures have finished executing and the resources used by the\n                executor have been reclaimed.\n        \"\"\"\n        pass\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.shutdown(wait=True)\n        return False\n\n\nclass BrokenExecutor(RuntimeError):\n    \"\"\"\n    Raised when a executor has become non-functional after a severe failure.\n    \"\"\"\n", 643], "/home/edx/PycharmProjects/examples/threads/utils.py": ["import threading\nimport time\n\nfrom os import getpid\nfrom datetime import datetime\nfrom functools import wraps\n\n\ndef timeit(func):\n    @wraps(func)\n    def timeit_wrapper(*args, **kwargs):\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        total_time = end_time - start_time\n        print(f'Function {func.__name__}{args} {kwargs} Took {total_time:.4f} seconds')\n        return result\n    return timeit_wrapper\n\n\nclass ThreadInfo:\n    def __init__(self):\n        self.name = threading.currentThread().name\n        self.pid = getpid()\n        self.thread_id = threading.currentThread().ident\n        self.created = datetime.now()\n\n    def __repr__(self):\n        return \"ThreadInfo: {attrs}\".format(attrs=\", \".join(\"{}={!r}\".format(k, v) for k, v in self.__dict__.items()))\n", 29], "/home/edx/.pyenv/versions/examples/lib/python3.8/site-packages/viztracer/tracer.py": ["# Licensed under the Apache License: http://www.apache.org/licenses/LICENSE-2.0\n# For details: https://github.com/gaogaotiantian/viztracer/blob/master/NOTICE.txt\n\nimport builtins\nimport gc\nfrom io import StringIO\nimport os\nfrom typing import Any, Dict, Optional, Sequence, Union\nimport viztracer.snaptrace as snaptrace  # type: ignore\n\nfrom . import __version__\n\n\nclass _VizTracer:\n    def __init__(\n            self,\n            tracer_entries: int = 1000000,\n            max_stack_depth: int = -1,\n            include_files: Optional[Sequence[str]] = None,\n            exclude_files: Optional[Sequence[str]] = None,\n            ignore_c_function: bool = False,\n            ignore_frozen: bool = False,\n            log_func_retval: bool = False,\n            log_func_args: bool = False,\n            log_print: bool = False,\n            log_gc: bool = False,\n            log_async: bool = False,\n            trace_self: bool = False,\n            min_duration: float = 0,\n            vdb: bool = False):\n        self.initialized = False\n        self.enable = False\n        self.parsed = False\n        self._tracer = snaptrace.Tracer(tracer_entries)\n        self.tracer_entries = tracer_entries\n        self.data: Dict[str, Any] = {}\n        self.verbose = 0\n        self.max_stack_depth = max_stack_depth\n        self.curr_stack_depth = 0\n        self.include_files = include_files\n        self.exclude_files = exclude_files\n        self.ignore_c_function = ignore_c_function\n        self.ignore_frozen = ignore_frozen\n        self.log_func_retval = log_func_retval\n        self.log_func_args = log_func_args\n        self.log_async = log_async\n        self.min_duration = min_duration\n        self.vdb = vdb\n        self.log_print = log_print\n        self.log_gc = log_gc\n        self.trace_self = trace_self\n        self.system_print = builtins.print\n        self.total_entries = 0\n        self.gc_start_args: Dict[str, int] = {}\n        self.initialized = True\n\n    @property\n    def max_stack_depth(self) -> int:\n        return self.__max_stack_depth\n\n    @max_stack_depth.setter\n    def max_stack_depth(self, max_stack_depth: Union[str, int]):\n        if isinstance(max_stack_depth, str):\n            try:\n                self.__max_stack_depth = int(max_stack_depth)\n            except ValueError:\n                raise ValueError(\"Error when trying to convert max_stack_depth {} to integer.\".format(max_stack_depth))\n        elif isinstance(max_stack_depth, int):\n            self.__max_stack_depth = max_stack_depth\n        else:\n            raise ValueError(\"Error when trying to convert max_stack_depth {} to integer.\".format(max_stack_depth))\n        self.config()\n\n    @property\n    def include_files(self) -> Optional[Sequence[str]]:\n        return self.__include_files\n\n    @include_files.setter\n    def include_files(self, include_files: Optional[Sequence[str]]):\n        if include_files is None:\n            self.__include_files = None\n        elif isinstance(include_files, list):\n            if include_files:\n                self.__include_files = include_files[:] + [os.path.abspath(f) for f in include_files if not f.startswith(\"/\")]\n            else:\n                self.__include_files = None\n        else:\n            raise ValueError(\"include_files has to be a list\")\n        self.config()\n\n    @property\n    def exclude_files(self) -> Optional[Sequence[str]]:\n        return self.__exclude_files\n\n    @exclude_files.setter\n    def exclude_files(self, exclude_files: Optional[Sequence[str]]):\n        if exclude_files is None:\n            self.__exclude_files = None\n        elif isinstance(exclude_files, list):\n            if exclude_files:\n                self.__exclude_files = exclude_files[:] + [os.path.abspath(f) for f in exclude_files if not f.startswith(\"/\")]\n            else:\n                self.__exclude_files = None\n        else:\n            raise ValueError(\"exclude_files has to be a list\")\n        self.config()\n\n    @property\n    def ignore_c_function(self) -> bool:\n        return self.__ignore_c_function\n\n    @ignore_c_function.setter\n    def ignore_c_function(self, ignore_c_function: bool):\n        if isinstance(ignore_c_function, bool):\n            self.__ignore_c_function = ignore_c_function\n        else:\n            raise ValueError(\"ignore_c_function needs to be True or False, not {}\".format(ignore_c_function))\n        self.config()\n\n    @property\n    def ignore_frozen(self) -> bool:\n        return self.__ignore_frozen\n\n    @ignore_frozen.setter\n    def ignore_frozen(self, ignore_frozen: bool):\n        if isinstance(ignore_frozen, bool):\n            self.__ignore_frozen = ignore_frozen\n        else:\n            raise ValueError(\"ignore_frozen needs to be True or False, not {}\".format(ignore_frozen))\n        self.config()\n\n    @property\n    def log_func_retval(self) -> bool:\n        return self.__log_func_retval\n\n    @log_func_retval.setter\n    def log_func_retval(self, log_func_retval: bool):\n        if isinstance(log_func_retval, bool):\n            self.__log_func_retval = log_func_retval\n        else:\n            raise ValueError(\"log_func_retval needs to be True or False, not {}\".format(log_func_retval))\n        self.config()\n\n    @property\n    def log_async(self) -> bool:\n        return self.__log_async\n\n    @log_async.setter\n    def log_async(self, log_async: bool):\n        if isinstance(log_async, bool):\n            self.__log_async = log_async\n        else:\n            raise ValueError(\"log_async needs to be True or False, not {}\".format(log_async))\n        self.config()\n\n    @property\n    def log_print(self) -> bool:\n        return self.__log_print\n\n    @log_print.setter\n    def log_print(self, log_print: bool):\n        if isinstance(log_print, bool):\n            self.__log_print = log_print\n        else:\n            raise ValueError(\"log_print needs to be True or False, not {}\".format(log_print))\n\n    @property\n    def log_func_args(self) -> bool:\n        return self.__log_func_args\n\n    @log_func_args.setter\n    def log_func_args(self, log_func_args: bool):\n        if isinstance(log_func_args, bool):\n            self.__log_func_args = log_func_args\n        else:\n            raise ValueError(\"log_func_args needs to be True or False, not {}\".format(log_func_args))\n        self.config()\n\n    @property\n    def log_gc(self) -> bool:\n        return self.__log_gc\n\n    @log_gc.setter\n    def log_gc(self, log_gc: bool):\n        if isinstance(log_gc, bool):\n            self.__log_gc = log_gc\n            if log_gc:\n                gc.callbacks.append(self.add_garbage_collection)\n            elif self.add_garbage_collection in gc.callbacks:\n                gc.callbacks.remove(self.add_garbage_collection)\n        else:\n            raise ValueError(\"log_gc needs to be True or False, not {}\".format(log_gc))\n\n    @property\n    def vdb(self) -> bool:\n        return self.__vdb\n\n    @vdb.setter\n    def vdb(self, vdb: bool):\n        if isinstance(vdb, bool):\n            self.__vdb = vdb\n        else:\n            raise ValueError(\"vdb needs to be True or False, not {}\".format(vdb))\n        self.config()\n\n    @property\n    def verbose(self) -> int:\n        return self.__verbose\n\n    @verbose.setter\n    def verbose(self, verbose: Union[str, int]):\n        if isinstance(verbose, str):\n            try:\n                self.__verbose = int(verbose)\n            except ValueError:\n                raise ValueError(\"Verbose needs to be an integer, not {}\".format(verbose))\n        elif isinstance(verbose, int):\n            self.__verbose = verbose\n        else:\n            raise ValueError(\"Verbose needs to be an integer, not {}\".format(verbose))\n        self.config()\n\n    @property\n    def min_duration(self) -> float:\n        return self.__min_duration\n\n    @min_duration.setter\n    def min_duration(self, min_duration: float):\n        if isinstance(min_duration, int) or isinstance(min_duration, float):\n            self.__min_duration = float(min_duration)\n        else:\n            raise ValueError(\"duration needs to be a float, not {}\".format(min_duration))\n        self.config()\n\n    def config(self):\n        if not self.initialized:\n            return\n\n        cfg = {\n            \"verbose\": self.verbose,\n            \"lib_file_path\": os.path.dirname(os.path.realpath(__file__)),\n            \"max_stack_depth\": self.max_stack_depth,\n            \"include_files\": self.include_files,\n            \"exclude_files\": self.exclude_files,\n            \"ignore_c_function\": self.ignore_c_function,\n            \"ignore_frozen\": self.ignore_frozen,\n            \"log_func_retval\": self.log_func_retval,\n            \"vdb\": self.vdb,\n            \"log_func_args\": self.log_func_args,\n            \"log_async\": self.log_async,\n            \"trace_self\": self.trace_self,\n            \"min_duration\": self.min_duration\n        }\n\n        self._tracer.config(**cfg)\n\n    def start(self):\n        self.enable = True\n        self.parsed = False\n        if self.log_print:\n            self.overload_print()\n        if self.include_files is not None and self.exclude_files is not None:\n            raise Exception(\"include_files and exclude_files can't be both specified!\")\n        self.config()\n        self._tracer.start()\n\n    def stop(self):\n        self.enable = False\n        if self.log_print:\n            self.restore_print()\n        self._tracer.stop()\n\n    def pause(self):\n        if self.enable:\n            self._tracer.pause()\n\n    def resume(self):\n        if self.enable:\n            self._tracer.resume()\n\n    def clear(self):\n        self._tracer.clear()\n\n    def cleanup(self):\n        self._tracer.cleanup()\n\n    def getts(self) -> float:\n        return self._tracer.getts()\n\n    def add_instant(self, name: str, args: Any = None, scope: str = \"g\"):\n        if self.enable:\n            if scope not in [\"g\", \"p\", \"t\"]:\n                print(\"Scope has to be one of g, p, t\")\n                return\n            self._tracer.addinstant(name, args, scope)\n\n    def add_variable(self, name: str, var: Any, event: str = \"instant\"):\n        if self.enable:\n            if event == \"instant\":\n                self.add_instant(f\"{name} = {repr(var)}\", scope=\"p\")\n            elif event == \"counter\":\n                if isinstance(var, int or type(var) is float):\n                    self.add_counter(name, {name: var})\n                else:\n                    raise ValueError(\"{}({}) is not a number\".format(name, var))\n            else:\n                raise ValueError(\"{} is not supported\".format(event))\n\n    def add_counter(self, name: str, args: Dict[str, Any]):\n        if self.enable:\n            self._tracer.addcounter(name, args)\n\n    def add_object(self, ph: str, obj_id: str, name: str, args: Optional[Dict[str, Any]] = None):\n        if self.enable:\n            self._tracer.addobject(ph, obj_id, name, args)\n\n    def add_func_args(self, key: str, value: Any):\n        if self.enable:\n            self._tracer.addfunctionarg(key, value)\n\n    def add_raw(self, raw: Dict[str, Any]):\n        self._tracer.addraw(raw)\n\n    def add_garbage_collection(self, phase: str, info: Dict[str, Any]):\n        if self.enable:\n            if phase == \"start\":\n                args = {\n                    \"collecting\": 1,\n                    \"collected\": 0,\n                    \"uncollectable\": 0\n                }\n                self.add_counter(\"garbage collection\", args)\n                self.gc_start_args = args\n            if phase == \"stop\" and self.gc_start_args:\n                self.gc_start_args[\"collected\"] = info[\"collected\"]\n                self.gc_start_args[\"uncollectable\"] = info[\"uncollectable\"]\n                self.gc_start_args = {}\n                self.add_counter(\"garbage collection\", {\n                    \"collecting\": 0,\n                    \"collected\": 0,\n                    \"uncollectable\": 0\n                })\n\n    def add_func_exec(self, name: str, val: Any, lineno: int):\n        exec_line = \"({}) {} = {}\".format(lineno, name, val)\n        curr_args = self._tracer.getfunctionarg()\n        if not curr_args:\n            self._tracer.addfunctionarg(\"exec_steps\", [exec_line])\n        else:\n            if \"exec_steps\" in curr_args:\n                curr_args[\"exec_steps\"].append(exec_line)\n            else:\n                curr_args[\"exec_steps\"] = [exec_line]\n\n    def _set_curr_stack_depth(self, stack_depth: int):\n        self._tracer.setcurrstack(stack_depth)\n\n    def parse(self) -> int:\n        # parse() is also performance sensitive. We could have a lot of entries\n        # in buffer, so try not to add any overhead when parsing\n        # We parse the buffer into Chrome Trace Event Format\n        self.stop()\n        if not self.parsed:\n            self.data = {\n                \"traceEvents\": self._tracer.load(),\n                \"viztracer_metadata\": {\n                    \"version\": __version__,\n                    \"overflow\": False\n                }\n            }\n            metadata_count = 0\n            for d in self.data[\"traceEvents\"]:\n                if d[\"ph\"] == \"M\":\n                    metadata_count += 1\n                else:\n                    break\n            self.total_entries = len(self.data[\"traceEvents\"]) - metadata_count\n            if self.total_entries == self.tracer_entries:\n                self.data[\"viztracer_metadata\"][\"overflow\"] = True\n            self.parsed = True\n\n        return self.total_entries\n\n    def dump(self, filename: str) -> None:\n        self._tracer.dump(filename)\n\n    def overload_print(self):\n        self.system_print = builtins.print\n\n        def new_print(*args, **kwargs):\n            self.pause()\n            io = StringIO()\n            kwargs[\"file\"] = io\n            self.system_print(*args, **kwargs)\n            self.add_instant(f\"print - {io.getvalue()}\")\n            self.resume()\n        builtins.print = new_print\n\n    def restore_print(self):\n        builtins.print = self.system_print\n", 400]}, "functions": {"_acquireLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:214)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 214], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:772)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 772], "_checkLevel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:189)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 189], "_releaseLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:223)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 223], "_addHandlerRef (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:839)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 839], "RLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:81)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 81], "add (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:81)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py", 81], "_register_at_fork_reinit_lock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:244)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 244], "createLock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:887)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 887], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:858)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 858], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1047)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1047], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:420)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 420], "validate (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:426)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 426], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:555)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 555], "setFormatter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:955)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 955], "addHandler (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1589)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1589], "_clear_cache (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1360)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1360], "setLevel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1405)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1405], "basicConfig (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1893)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1893], "__init__ (/home/edx/PycharmProjects/examples/threads/race_conditions.py:13)": ["/home/edx/PycharmProjects/examples/threads/race_conditions.py", 13], "getEffectiveLevel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1663)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1663], "isEnabledFor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1677)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1677], "<lambda> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:156)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 156], "normcase (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:52)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py", 52], "findCaller (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1502)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1502], "__subclasshook__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py:392)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_collections_abc.py", 392], "__subclasscheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:100)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py", 100], "__instancecheck__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py:96)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/abc.py", 96], "getLevelName (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:119)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 119], "_get_sep (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:41)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py", 41], "basename (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:140)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py", 140], "_splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py:121)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/genericpath.py", 121], "splitext (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py:117)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/posixpath.py", 117], "current_thread (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1306)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 1306], "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1031)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 1031], "current_process (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:37)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py", 37], "name (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py:189)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/multiprocessing/process.py", 189], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:284)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 284], "makeRecord (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1538)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1538], "filter (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:792)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 792], "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:894)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 894], "getMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:360)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 360], "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:423)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 423], "usesTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:629)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 629], "formatTime (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:584)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 584], "_format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:431)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 431], "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:434)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 434], "formatMessage (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:635)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 635], "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:651)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 651], "format (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:914)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 914], "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:901)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 901], "flush (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1058)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1058], "emit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1069)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1069], "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:937)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 937], "callHandlers (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1633)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1633], "handle (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1579)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1579], "_log (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1553)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1553], "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:1424)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 1424], "info (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py:2059)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/logging/__init__.py", 2059], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:343)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py", 343], "_WorkItem (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:45)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 45], "BrokenThreadPool (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:109)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 109], "ThreadPoolExecutor (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:115)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 115], "<module> (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:4)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 4], "__getattr__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/__init__.py:40)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/__init__.py", 40], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:222)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 222], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:388)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 388], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:120)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 120], "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:632)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py", 632], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:316)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py", 316], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:46)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 46], "__enter__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:246)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 246], "_is_owned (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:261)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 261], "_release_save (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:255)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 255], "_acquire_restore (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:258)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 258], "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:270)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 270], "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:249)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 249], "acquire (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:394)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 394], "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1095)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 1095], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:505)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 505], "_make_invoke_excepthook (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1177)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 1177], "__init__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:761)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 761], "is_set (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:513)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 513], "daemon (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1110)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 1110], "set_running_or_notify_cancel (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:477)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py", 477], "ident (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1047)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 1047], "__init__ (/home/edx/PycharmProjects/examples/threads/utils.py:22)": ["/home/edx/PycharmProjects/examples/threads/utils.py", 22], "<genexpr> (/home/edx/PycharmProjects/examples/threads/utils.py:29)": ["/home/edx/PycharmProjects/examples/threads/utils.py", 29], "__repr__ (/home/edx/PycharmProjects/examples/threads/utils.py:28)": ["/home/edx/PycharmProjects/examples/threads/utils.py", 28], "wait (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:540)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 540], "start (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:834)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 834], "__setitem__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:395)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py", 395], "_adjust_thread_count (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:193)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 193], "submit (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:158)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 158], "update (/home/edx/PycharmProjects/examples/threads/race_conditions.py:17)": ["/home/edx/PycharmProjects/examples/threads/race_conditions.py", 17], "timeit_wrapper (/home/edx/PycharmProjects/examples/threads/utils.py:10)": ["/home/edx/PycharmProjects/examples/threads/utils.py", 10], "notify (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:341)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 341], "notify_all (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:364)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 364], "_invoke_callbacks (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:325)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py", 325], "set_result (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:517)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py", 517], "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:52)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 52], "release (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:441)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 441], "_worker (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:66)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 66], "run (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:859)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 859], "_stop (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:944)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 944], "_wait_for_tstate_lock (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:1017)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 1017], "join (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py:979)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/threading.py", 979], "shutdown (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py:230)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/thread.py", 230], "__exit__ (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py:635)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/concurrent/futures/_base.py", 635], "main (/home/edx/PycharmProjects/examples/threads/race_conditions.py:31)": ["/home/edx/PycharmProjects/examples/threads/race_conditions.py", 31], "remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py:345)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/weakref.py", 345], "_remove (/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py:38)": ["/home/edx/.pyenv/versions/3.8.1/lib/python3.8/_weakrefset.py", 38], "log_print (/home/edx/.pyenv/versions/examples/lib/python3.8/site-packages/viztracer/tracer.py:156)": ["/home/edx/.pyenv/versions/examples/lib/python3.8/site-packages/viztracer/tracer.py", 156]}}}